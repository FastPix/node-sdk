/*
* This file is auto-generated.
 * Do not edit this file manually.
 * Your changes will be overwritten during the next generation.
 */

import * as z from "zod/v4-mini";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smartUnion.js";
import {
  AiResponseRecord,
  AiResponseRecord$inboundSchema,
} from "./airesponserecord.js";
import {
  AiSummaryRecord,
  AiSummaryRecord$inboundSchema,
} from "./aisummaryrecord.js";
import { AudioTrack, AudioTrack$inboundSchema } from "./audiotrack.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import { PlaybackId, PlaybackId$inboundSchema } from "./playbackid.js";
import { SubtitleTrack, SubtitleTrack$inboundSchema } from "./subtitletrack.js";
import {
  TracksSubtitles,
  TracksSubtitles$inboundSchema,
} from "./trackssubtitles.js";
import { VideoTrack, VideoTrack$inboundSchema } from "./videotrack.js";

/**
 * The quality tier applied to the media.
 */
export const SourceAccessMediaMediaQuality = {
  Standard: "standard",
  Pro: "pro",
  Premium: "premium",
} as const;
/**
 * The quality tier applied to the media.
 */
export type SourceAccessMediaMediaQuality = OpenEnum<
  typeof SourceAccessMediaMediaQuality
>;

/**
 * The maximum resolution specified by the user for the media.
 */
export const SourceAccessMediaMaxResolution = {
  TwoThousandOneHundredAndSixtyp: "2160p",
  OneThousandFourHundredAndFortyp: "1440p",
  OneThousandAndEightyp: "1080p",
  SevenHundredAndTwentyp: "720p",
  FourHundredAndEightyp: "480p",
} as const;
/**
 * The maximum resolution specified by the user for the media.
 */
export type SourceAccessMediaMaxResolution = OpenEnum<
  typeof SourceAccessMediaMaxResolution
>;

/**
 * The actual resolution of the uploaded media. This represents the native quality of the source media.
 */
export const SourceAccessMediaSourceResolution = {
  TwoThousandOneHundredAndSixtyp: "2160p",
  OneThousandFourHundredAndFortyp: "1440p",
  OneThousandAndEightyp: "1080p",
  SevenHundredAndTwentyp: "720p",
  FourHundredAndEightyp: "480p",
} as const;
/**
 * The actual resolution of the uploaded media. This represents the native quality of the source media.
 */
export type SourceAccessMediaSourceResolution = OpenEnum<
  typeof SourceAccessMediaSourceResolution
>;

/**
 * Determines the media's status, which can be one of the possible values.
 */
export const SourceAccessMediaStatus = {
  Created: "Created",
  Downloading: "Downloading",
  Downloaded: "Downloaded",
  Validating: "Validating",
  InQueue: "In Queue",
  Processing: "Processing",
  Ready: "Ready",
  Failed: "Failed",
} as const;
/**
 * Determines the media's status, which can be one of the possible values.
 */
export type SourceAccessMediaStatus = OpenEnum<typeof SourceAccessMediaStatus>;

export type SourceAccessMediaTrack = VideoTrack | AudioTrack | SubtitleTrack;

export type SourceAccessMedia = {
  /**
   * A video thumbnail is a still image that acts as the preview image for your video.
   */
  thumbnail?: string | null | undefined;
  /**
   * The unique identifier assigned to the media when created. The value must be a valid UUID.
   */
  id?: string | undefined;
  /**
   * A unique identifier is generated by FastPix for the workspace.
   */
  workspaceId?: string | undefined;
  /**
   * You can search for videos with specific key value pairs using metadata, when you tag a video in "key" : "value" pairs. Dynamic metadata allows you to define a key that allows any value pair. You can have maximum of 255 characters and upto 10 entries are allowed.
   *
   * @remarks
   */
  metadata?: { [k: string]: string } | null | undefined;
  /**
   * The quality tier applied to the media.
   */
  mediaQuality?: SourceAccessMediaMediaQuality | undefined;
  /**
   * The unique identifier of the user who created this media.
   */
  creatorId?: string | null | undefined;
  /**
   * Title of the media file.
   */
  title?: string | null | undefined;
  /**
   * The maximum resolution specified by the user for the media.
   */
  maxResolution?: SourceAccessMediaMaxResolution | undefined;
  /**
   * The actual resolution of the uploaded media. This represents the native quality of the source media.
   */
  sourceResolution?: SourceAccessMediaSourceResolution | undefined;
  /**
   * Determines the media's status, which can be one of the possible values.
   */
  status?: SourceAccessMediaStatus | undefined;
  /**
   * The sourceAccess parameter determines whether the original media file is accessible. Set to true to enable access or false to restrict it.
   */
  sourceAccess?: boolean | null | undefined;
  /**
   * A collection of Playback ID objects utilized for crafting HLS playback URLs.
   */
  playbackIds?: Array<PlaybackId> | undefined;
  /**
   * A media consists of different media tracks, like video, audio, and subtitle, all combined.
   */
  tracks?: Array<VideoTrack | AudioTrack | SubtitleTrack> | undefined;
  /**
   * List of generated subtitle tracks associated with the media.
   */
  generatedSubtitles?: Array<TracksSubtitles> | null | undefined;
  /**
   * Represents an AI response record containing status and data for AI-generated features like summary, chapters, named entities, or moderation.
   */
  summary?: AiSummaryRecord | undefined;
  /**
   * Represents an AI response record containing status and data for AI-generated features like summary, chapters, named entities, or moderation.
   */
  chapters?: AiResponseRecord | undefined;
  /**
   * Represents an AI response record containing status and data for AI-generated features like summary, chapters, named entities, or moderation.
   */
  namedEntities?: AiResponseRecord | undefined;
  /**
   * Represents an AI response record containing status and data for AI-generated features like summary, chapters, named entities, or moderation.
   */
  moderation?: AiResponseRecord | undefined;
  /**
   * Indicates whether the media contains only audio (no video track).
   */
  isAudioOnly?: boolean | null | undefined;
  /**
   * Indicates whether subtitles are available for the media.
   */
  subtitleAvailable?: boolean | null | undefined;
  /**
   * The length of the media in seconds, with a maximum allowed duration of 12 hours per individual media.
   */
  duration?: string | undefined;
  /**
   * The aspect ratio of a video describes its shape based on the relationship between its width and height.
   */
  aspectRatio?: string | null | undefined;
  /**
   * Time the media was created, defined as a localDateTime (UTC Time).
   */
  createdAt?: Date | undefined;
  /**
   * Time the media was updated, defined as a localDateTime (UTC Time).
   */
  updatedAt?: Date | undefined;
};

/** @internal */
export const SourceAccessMediaMediaQuality$inboundSchema: z.ZodMiniType<
  SourceAccessMediaMediaQuality,
  unknown
> = openEnums.inboundSchema(SourceAccessMediaMediaQuality);

/** @internal */
export const SourceAccessMediaMaxResolution$inboundSchema: z.ZodMiniType<
  SourceAccessMediaMaxResolution,
  unknown
> = openEnums.inboundSchema(SourceAccessMediaMaxResolution);

/** @internal */
export const SourceAccessMediaSourceResolution$inboundSchema: z.ZodMiniType<
  SourceAccessMediaSourceResolution,
  unknown
> = openEnums.inboundSchema(SourceAccessMediaSourceResolution);

/** @internal */
export const SourceAccessMediaStatus$inboundSchema: z.ZodMiniType<
  SourceAccessMediaStatus,
  unknown
> = openEnums.inboundSchema(SourceAccessMediaStatus);

/** @internal */
export const SourceAccessMediaTrack$inboundSchema: z.ZodMiniType<
  SourceAccessMediaTrack,
  unknown
> = smartUnion([
  VideoTrack$inboundSchema,
  AudioTrack$inboundSchema,
  SubtitleTrack$inboundSchema,
]);

export function sourceAccessMediaTrackFromJSON(
  jsonString: string,
): SafeParseResult<SourceAccessMediaTrack, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SourceAccessMediaTrack$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SourceAccessMediaTrack' from JSON`,
  );
}

/** @internal */
export const SourceAccessMedia$inboundSchema: z.ZodMiniType<
  SourceAccessMedia,
  unknown
> = z.object({
  thumbnail: z.optional(z.nullable(types.string())),
  id: types.optional(types.string()),
  workspaceId: types.optional(types.string()),
  metadata: z.optional(z.nullable(z.record(z.string(), types.string()))),
  mediaQuality: types.optional(SourceAccessMediaMediaQuality$inboundSchema),
  creatorId: z.optional(z.nullable(types.string())),
  title: z.optional(z.nullable(types.string())),
  maxResolution: z._default(
    SourceAccessMediaMaxResolution$inboundSchema,
    "1080p",
  ),
  sourceResolution: z._default(
    SourceAccessMediaSourceResolution$inboundSchema,
    "1080p",
  ),
  status: types.optional(SourceAccessMediaStatus$inboundSchema),
  sourceAccess: z.optional(z.nullable(types.boolean())),
  playbackIds: types.optional(z.array(PlaybackId$inboundSchema)),
  tracks: types.optional(
    z.array(
      smartUnion([
        VideoTrack$inboundSchema,
        AudioTrack$inboundSchema,
        SubtitleTrack$inboundSchema,
      ]),
    ),
  ),
  generatedSubtitles: z.optional(
    z.nullable(z.array(TracksSubtitles$inboundSchema)),
  ),
  summary: types.optional(AiSummaryRecord$inboundSchema),
  chapters: types.optional(AiResponseRecord$inboundSchema),
  namedEntities: types.optional(AiResponseRecord$inboundSchema),
  moderation: types.optional(AiResponseRecord$inboundSchema),
  isAudioOnly: z.optional(z.nullable(types.boolean())),
  subtitleAvailable: z.optional(z.nullable(types.boolean())),
  duration: types.optional(types.string()),
  aspectRatio: z.optional(z.nullable(types.string())),
  createdAt: types.optional(types.date()),
  updatedAt: types.optional(types.date()),
});

export function sourceAccessMediaFromJSON(
  jsonString: string,
): SafeParseResult<SourceAccessMedia, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SourceAccessMedia$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SourceAccessMedia' from JSON`,
  );
}
