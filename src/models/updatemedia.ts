/*
* This file is auto-generated.
 * Do not edit this file manually.
 * Your changes will be overwritten during the next generation.
 */

import * as z from "zod/v4-mini";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smartUnion.js";
import {
  AiResponseRecord,
  AiResponseRecord$inboundSchema,
} from "./airesponserecord.js";
import {
  AiSummaryRecord,
  AiSummaryRecord$inboundSchema,
} from "./aisummaryrecord.js";
import { AudioTrack, AudioTrack$inboundSchema } from "./audiotrack.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import { PlaybackId, PlaybackId$inboundSchema } from "./playbackid.js";
import { SubtitleTrack, SubtitleTrack$inboundSchema } from "./subtitletrack.js";
import {
  TracksSubtitles,
  TracksSubtitles$inboundSchema,
} from "./trackssubtitles.js";
import { VideoTrack, VideoTrack$inboundSchema } from "./videotrack.js";

/**
 * The quality tier applied to the media.
 */
export const UpdateMediaMediaQuality = {
  Standard: "standard",
  Pro: "pro",
  Premium: "premium",
} as const;
/**
 * The quality tier applied to the media.
 */
export type UpdateMediaMediaQuality = OpenEnum<typeof UpdateMediaMediaQuality>;

/**
 * The maximum resolution specified by the user for the media.
 */
export const UpdateMediaMaxResolution = {
  TwoThousandOneHundredAndSixtyp: "2160p",
  OneThousandFourHundredAndFortyp: "1440p",
  OneThousandAndEightyp: "1080p",
  SevenHundredAndTwentyp: "720p",
  FourHundredAndEightyp: "480p",
  ThreeHundredAndSixtyp: "360p",
} as const;
/**
 * The maximum resolution specified by the user for the media.
 */
export type UpdateMediaMaxResolution = OpenEnum<
  typeof UpdateMediaMaxResolution
>;

/**
 * The actual resolution of the uploaded media. This represents the native quality of the source media.
 */
export const UpdateMediaSourceResolution = {
  TwoThousandOneHundredAndSixtyp: "2160p",
  OneThousandFourHundredAndFortyp: "1440p",
  OneThousandAndEightyp: "1080p",
  SevenHundredAndTwentyp: "720p",
  FourHundredAndEightyp: "480p",
  ThreeHundredAndSixtyp: "360p",
} as const;
/**
 * The actual resolution of the uploaded media. This represents the native quality of the source media.
 */
export type UpdateMediaSourceResolution = OpenEnum<
  typeof UpdateMediaSourceResolution
>;

/**
 * Determines the media's status, which can be one of the possible values.
 */
export const UpdateMediaStatus = {
  Created: "Created",
  Downloading: "Downloading",
  Downloaded: "Downloaded",
  Validating: "Validating",
  InQueue: "In Queue",
  Processing: "Processing",
  Ready: "Ready",
  Failed: "Failed",
} as const;
/**
 * Determines the media's status, which can be one of the possible values.
 */
export type UpdateMediaStatus = OpenEnum<typeof UpdateMediaStatus>;

export type UpdateMediaTrack = VideoTrack | AudioTrack | SubtitleTrack;

export type UpdateMedia = {
  /**
   * A video thumbnail is a still image that acts as the preview image for your video.
   */
  thumbnail?: string | undefined;
  /**
   * The unique identifier assigned to the media when created. The value must be a valid UUID.
   */
  id?: string | undefined;
  /**
   * A unique identifier is generated by FastPix for the workspace.
   */
  workspaceId?: string | undefined;
  /**
   * You can search for videos with specific key value pairs using metadata, when you tag a video in "key" : "value" pairs. Dynamic metadata allows you to define a key that allows any value pair. You can have maximum of 255 characters and upto 10 entries are allowed.
   */
  metadata?: { [k: string]: string } | null | undefined;
  /**
   * The quality tier applied to the media.
   */
  mediaQuality?: UpdateMediaMediaQuality | undefined;
  /**
   * The unique identifier of the user who created this media.
   */
  creatorId?: string | undefined;
  /**
   * Title of the media file.
   */
  title?: string | undefined;
  /**
   * The maximum resolution specified by the user for the media.
   */
  maxResolution?: UpdateMediaMaxResolution | undefined;
  /**
   * The actual resolution of the uploaded media. This represents the native quality of the source media.
   */
  sourceResolution?: UpdateMediaSourceResolution | undefined;
  /**
   * Determines the media's status, which can be one of the possible values.
   */
  status?: UpdateMediaStatus | undefined;
  /**
   * The sourceAccess parameter determines whether the original media file is accessible. Set to true to enable access or false to restrict it
   */
  sourceAccess?: boolean | undefined;
  /**
   * A collection of Playback ID objects utilized for crafting HLS playback URLs.
   */
  playbackIds?: Array<PlaybackId> | undefined;
  /**
   * A media consists of different media tracks, like video, audio, and subtitle, all combined.
   */
  tracks?: Array<VideoTrack | AudioTrack | SubtitleTrack> | undefined;
  /**
   * List of generated subtitle tracks associated with the media.
   */
  generatedSubtitles?: Array<TracksSubtitles> | null | undefined;
  /**
   * Represents an AI response record containing status and data for AI-generated features like summary, chapters, named entities, or moderation.
   */
  summary?: AiSummaryRecord | undefined;
  /**
   * Represents an AI response record containing status and data for AI-generated features like summary, chapters, named entities, or moderation.
   */
  chapters?: AiResponseRecord | undefined;
  /**
   * Represents an AI response record containing status and data for AI-generated features like summary, chapters, named entities, or moderation.
   */
  namedEntities?: AiResponseRecord | undefined;
  /**
   * Represents an AI response record containing status and data for AI-generated features like summary, chapters, named entities, or moderation.
   */
  moderation?: AiResponseRecord | undefined;
  /**
   * Indicates whether the media contains only audio (no video track).
   */
  isAudioOnly?: boolean | null | undefined;
  /**
   * Specifies whether subtitle tracks are available for the media.
   */
  subtitleAvailable?: boolean | undefined;
  /**
   * The length of the media in seconds, with a maximum allowed duration of 12 hours per individual media.
   */
  duration?: string | undefined;
  /**
   * The aspect ratio of a video is a value that describes the relative shape of a video based on its width and height.
   */
  aspectRatio?: string | undefined;
  /**
   * Time the media was created, defined as a localDateTime (UTC Time).
   */
  createdAt?: Date | undefined;
  /**
   * Time the media was updated, defined as a localDateTime (UTC Time).
   */
  updatedAt?: Date | undefined;
};

/** @internal */
export const UpdateMediaMediaQuality$inboundSchema: z.ZodMiniType<
  UpdateMediaMediaQuality,
  unknown
> = openEnums.inboundSchema(UpdateMediaMediaQuality);

/** @internal */
export const UpdateMediaMaxResolution$inboundSchema: z.ZodMiniType<
  UpdateMediaMaxResolution,
  unknown
> = openEnums.inboundSchema(UpdateMediaMaxResolution);

/** @internal */
export const UpdateMediaSourceResolution$inboundSchema: z.ZodMiniType<
  UpdateMediaSourceResolution,
  unknown
> = openEnums.inboundSchema(UpdateMediaSourceResolution);

/** @internal */
export const UpdateMediaStatus$inboundSchema: z.ZodMiniType<
  UpdateMediaStatus,
  unknown
> = openEnums.inboundSchema(UpdateMediaStatus);

/** @internal */
export const UpdateMediaTrack$inboundSchema: z.ZodMiniType<
  UpdateMediaTrack,
  unknown
> = smartUnion([
  VideoTrack$inboundSchema,
  AudioTrack$inboundSchema,
  SubtitleTrack$inboundSchema,
]);

export function updateMediaTrackFromJSON(
  jsonString: string,
): SafeParseResult<UpdateMediaTrack, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateMediaTrack$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateMediaTrack' from JSON`,
  );
}

/** @internal */
export const UpdateMedia$inboundSchema: z.ZodMiniType<UpdateMedia, unknown> = z
  .object({
    thumbnail: types.optional(types.string()),
    id: types.optional(types.string()),
    workspaceId: types.optional(types.string()),
    metadata: z.optional(z.nullable(z.record(z.string(), types.string()))),
    mediaQuality: types.optional(UpdateMediaMediaQuality$inboundSchema),
    creatorId: z._default(
      types.string(),
      "8fa85f64-5717-4562-b3fc-2c963f66afa6",
    ),
    title: z._default(types.string(), "My Video Title"),
    maxResolution: z._default(UpdateMediaMaxResolution$inboundSchema, "1080p"),
    sourceResolution: z._default(
      UpdateMediaSourceResolution$inboundSchema,
      "1080p",
    ),
    status: types.optional(UpdateMediaStatus$inboundSchema),
    sourceAccess: types.optional(types.boolean()),
    playbackIds: types.optional(z.array(PlaybackId$inboundSchema)),
    tracks: types.optional(
      z.array(
        smartUnion([
          VideoTrack$inboundSchema,
          AudioTrack$inboundSchema,
          SubtitleTrack$inboundSchema,
        ]),
      ),
    ),
    generatedSubtitles: z.optional(
      z.nullable(z.array(TracksSubtitles$inboundSchema)),
    ),
    summary: types.optional(AiSummaryRecord$inboundSchema),
    chapters: types.optional(AiResponseRecord$inboundSchema),
    namedEntities: types.optional(AiResponseRecord$inboundSchema),
    moderation: types.optional(AiResponseRecord$inboundSchema),
    isAudioOnly: z.optional(z.nullable(types.boolean())),
    subtitleAvailable: types.optional(types.boolean()),
    duration: types.optional(types.string()),
    aspectRatio: types.optional(types.string()),
    createdAt: types.optional(types.date()),
    updatedAt: types.optional(types.date()),
  });

export function updateMediaFromJSON(
  jsonString: string,
): SafeParseResult<UpdateMedia, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateMedia$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateMedia' from JSON`,
  );
}
