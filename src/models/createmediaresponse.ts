/*
* This file is auto-generated.
 * Do not edit this file manually.
 * Your changes will be overwritten during the next generation.
 */

import * as z from "zod/v4-mini";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import { PlaybackId, PlaybackId$inboundSchema } from "./playbackid.js";

/**
 * Determines the media's status, which can be one of the possible values.
 */
export const CreateMediaResponseStatus = {
  Created: "Created",
  Downloading: "Downloading",
  Downloaded: "Downloaded",
  Validating: "Validating",
  InQueue: "In Queue",
  Processing: "Processing",
  Ready: "Ready",
  Failed: "Failed",
} as const;
/**
 * Determines the media's status, which can be one of the possible values.
 */
export type CreateMediaResponseStatus = OpenEnum<
  typeof CreateMediaResponseStatus
>;

/**
 * The quality tier applied to the media.
 */
export const CreateMediaResponseMediaQuality = {
  Standard: "standard",
  Pro: "pro",
  Premium: "premium",
} as const;
/**
 * The quality tier applied to the media.
 */
export type CreateMediaResponseMediaQuality = OpenEnum<
  typeof CreateMediaResponseMediaQuality
>;

/**
 * The maximum resolution tier defines the highest quality at which your media is available.
 */
export const CreateMediaResponseMaxResolution = {
  TwoThousandOneHundredAndSixtyp: "2160p",
  OneThousandFourHundredAndFortyp: "1440p",
  OneThousandAndEightyp: "1080p",
  SevenHundredAndTwentyp: "720p",
  FourHundredAndEightyp: "480p",
} as const;
/**
 * The maximum resolution tier defines the highest quality at which your media is available.
 */
export type CreateMediaResponseMaxResolution = OpenEnum<
  typeof CreateMediaResponseMaxResolution
>;

export type CreateMediaResponseInput = {
  /**
   * The type of input media. Commonly set to `video`.
   */
  type?: string | undefined;
  /**
   * The publicly accessible URL of the input video file.
   */
  url?: string | undefined;
};

export type CreateMediaResponse = {
  /**
   * The Media is assigned a universal unique identifier, which can contain a maximum of 255 characters.
   */
  id?: string | undefined;
  /**
   * FastPix allows for a free trial. Create as many media files as you like during the trial period. Remember, each clip can only be 10 seconds long and will be deleted after 24 hours. Also, all trial content will have the FastPix logo watermark.
   *
   * @remarks
   */
  trial?: boolean | undefined;
  /**
   * Determines the media's status, which can be one of the possible values.
   */
  status?: CreateMediaResponseStatus | undefined;
  /**
   * Time the media was created, defined as a localDateTime (UTC Time).
   */
  createdAt?: Date | undefined;
  /**
   * Time the media was updated, defined as a localDateTime (UTC Time).
   */
  updatedAt?: Date | undefined;
  /**
   * A collection of Playback ID objects utilized for crafting HLS playback URLs.
   */
  playbackIds?: Array<PlaybackId> | undefined;
  /**
   * You can search for videos with specific key value pairs using metadata, when you tag a video in "key" : "value" pairs. Dynamic metadata allows you to define a key that allows any value pair. You can have maximum of 255 characters and upto 10 entries are allowed.
   *
   * @remarks
   */
  metadata?: { [k: string]: string } | undefined;
  /**
   * The quality tier applied to the media.
   */
  mediaQuality?: CreateMediaResponseMediaQuality | undefined;
  /**
   * The sourceAccess parameter determines whether the original media file is accessible. Set to true to enable access or false to restrict it.
   *
   * @remarks
   */
  sourceAccess?: boolean | undefined;
  /**
   * The maximum resolution tier defines the highest quality at which your media is available.
   */
  maxResolution?: CreateMediaResponseMaxResolution | undefined;
  /**
   * A list of media input sources to be processed.
   */
  inputs?: Array<CreateMediaResponseInput> | undefined;
  /**
   * Enhance the quality and volume of the audio track. This is available for pre-recorded content only.
   *
   * @remarks
   */
  optimizeAudio?: boolean | undefined;
};

/** @internal */
export const CreateMediaResponseStatus$inboundSchema: z.ZodMiniType<
  CreateMediaResponseStatus,
  unknown
> = openEnums.inboundSchema(CreateMediaResponseStatus);

/** @internal */
export const CreateMediaResponseMediaQuality$inboundSchema: z.ZodMiniType<
  CreateMediaResponseMediaQuality,
  unknown
> = openEnums.inboundSchema(CreateMediaResponseMediaQuality);

/** @internal */
export const CreateMediaResponseMaxResolution$inboundSchema: z.ZodMiniType<
  CreateMediaResponseMaxResolution,
  unknown
> = openEnums.inboundSchema(CreateMediaResponseMaxResolution);

/** @internal */
export const CreateMediaResponseInput$inboundSchema: z.ZodMiniType<
  CreateMediaResponseInput,
  unknown
> = z.object({
  type: types.optional(types.string()),
  url: types.optional(types.string()),
});

export function createMediaResponseInputFromJSON(
  jsonString: string,
): SafeParseResult<CreateMediaResponseInput, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateMediaResponseInput$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateMediaResponseInput' from JSON`,
  );
}

/** @internal */
export const CreateMediaResponse$inboundSchema: z.ZodMiniType<
  CreateMediaResponse,
  unknown
> = z.object({
  id: types.optional(types.string()),
  trial: z._default(types.boolean(), true),
  status: types.optional(CreateMediaResponseStatus$inboundSchema),
  createdAt: types.optional(types.date()),
  updatedAt: types.optional(types.date()),
  playbackIds: types.optional(z.array(PlaybackId$inboundSchema)),
  metadata: types.optional(z.record(z.string(), types.string())),
  mediaQuality: types.optional(CreateMediaResponseMediaQuality$inboundSchema),
  sourceAccess: types.optional(types.boolean()),
  maxResolution: types.optional(CreateMediaResponseMaxResolution$inboundSchema),
  inputs: types.optional(
    z.array(z.lazy(() => CreateMediaResponseInput$inboundSchema)),
  ),
  optimizeAudio: types.optional(types.boolean()),
});

export function createMediaResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreateMediaResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateMediaResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateMediaResponse' from JSON`,
  );
}
