/*
* This file is auto-generated.
 * Do not edit this file manually.
 * Your changes will be overwritten during the next generation.
 */

import * as z from "zod/v4-mini";
import { ClosedEnum } from "../types/enums.js";
import { smartUnion } from "../types/smartUnion.js";
import {
  AudioInput,
  AudioInput$Outbound,
  AudioInput$outboundSchema,
} from "./audioinput.js";
import {
  PullVideoInput,
  PullVideoInput$Outbound,
  PullVideoInput$outboundSchema,
} from "./pullvideoinput.js";
import {
  SubtitleInput,
  SubtitleInput$Outbound,
  SubtitleInput$outboundSchema,
} from "./subtitleinput.js";
import {
  WatermarkInput,
  WatermarkInput$Outbound,
  WatermarkInput$outboundSchema,
} from "./watermarkinput.js";

export type Input =
  | SubtitleInput
  | WatermarkInput
  | AudioInput
  | PullVideoInput;

/**
 * Language codes are concise, standardized symbols that denote languages, utilizing either two or three characters for identification. The language code must be compliant with the BCP 47 standard to ensure compatibility. (for text only).
 *
 * @remarks
 */
export const CreateMediaRequestLanguageCode = {
  En: "en",
  It: "it",
  Pl: "pl",
  Es: "es",
  Fr: "fr",
  Ru: "ru",
  Nl: "nl",
} as const;
/**
 * Language codes are concise, standardized symbols that denote languages, utilizing either two or three characters for identification. The language code must be compliant with the BCP 47 standard to ensure compatibility. (for text only).
 *
 * @remarks
 */
export type CreateMediaRequestLanguageCode = ClosedEnum<
  typeof CreateMediaRequestLanguageCode
>;

/**
 * Generates subtitle files for audio/video files.
 *
 * @remarks
 */
export type Subtitles = {
  /**
   * Name of the language in which the subtitles will be generated.
   *
   * @remarks
   */
  languageName?: string | undefined;
  /**
   * You can search for videos with specific key value pairs using metadata, when you tag a video in "key" : "value" pairs. Dynamic metadata allows you to define a key that allows any value pair. You can have maximum of 255 characters and upto 10 entries are allowed.
   *
   * @remarks
   */
  metadata?: { [k: string]: string } | undefined;
  /**
   * Language codes are concise, standardized symbols that denote languages, utilizing either two or three characters for identification. The language code must be compliant with the BCP 47 standard to ensure compatibility. (for text only).
   *
   * @remarks
   */
  languageCode?: CreateMediaRequestLanguageCode | undefined;
};

/**
 * Determines whether access to the streamed content is kept private or available to all.
 *
 * @remarks
 */
export const CreateMediaRequestAccessPolicy = {
  Public: "public",
  Private: "private",
  Drm: "drm",
} as const;
/**
 * Determines whether access to the streamed content is kept private or available to all.
 *
 * @remarks
 */
export type CreateMediaRequestAccessPolicy = ClosedEnum<
  typeof CreateMediaRequestAccessPolicy
>;

/**
 * "capped_4k": Generates an mp4 video file up to 4k resolution "audioOnly": Generates an m4a audio file of the media file "audioOnly,capped_4k": Generates both video and audio media files for offline viewing
 *
 * @remarks
 */
export const CreateMediaRequestMp4Support = {
  Capped4k: "capped_4k",
  AudioOnly: "audioOnly",
  AudioOnlyCapped4k: "audioOnly,capped_4k",
} as const;
/**
 * "capped_4k": Generates an mp4 video file up to 4k resolution "audioOnly": Generates an m4a audio file of the media file "audioOnly,capped_4k": Generates both video and audio media files for offline viewing
 *
 * @remarks
 */
export type CreateMediaRequestMp4Support = ClosedEnum<
  typeof CreateMediaRequestMp4Support
>;

/**
 * The maximum resolution tier defines the highest quality at which your media is available.
 *
 * @remarks
 */
export const CreateMediaRequestMaxResolution = {
  TwoThousandOneHundredAndSixtyp: "2160p",
  OneThousandFourHundredAndFortyp: "1440p",
  OneThousandAndEightyp: "1080p",
  SevenHundredAndTwentyp: "720p",
  FourHundredAndEightyp: "480p",
} as const;
/**
 * The maximum resolution tier defines the highest quality at which your media is available.
 *
 * @remarks
 */
export type CreateMediaRequestMaxResolution = ClosedEnum<
  typeof CreateMediaRequestMaxResolution
>;

/**
 * The quality tier applied to the media.
 */
export const CreateMediaRequestMediaQuality = {
  Standard: "standard",
  Pro: "pro",
  Premium: "premium",
} as const;
/**
 * The quality tier applied to the media.
 */
export type CreateMediaRequestMediaQuality = ClosedEnum<
  typeof CreateMediaRequestMediaQuality
>;

export type Summary = {
  /**
   * Enable or disable the summary feature for the media.
   *
   * @remarks
   * Set to true to enable summary or false to disable.
   */
  generate?: boolean | undefined;
  /**
   * Specifies the desired word count for the generated summary.
   *
   * @remarks
   * - The value must be between **30** and **250** words.
   */
  summaryLength?: number | undefined;
};

/**
 * Defines the type of input. Possible values include video, audio, or av.
 *
 * @remarks
 */
export const CreateMediaRequestType = {
  Video: "video",
  Audio: "audio",
  Av: "av",
} as const;
/**
 * Defines the type of input. Possible values include video, audio, or av.
 *
 * @remarks
 */
export type CreateMediaRequestType = ClosedEnum<typeof CreateMediaRequestType>;

export type Moderation = {
  /**
   * Defines the type of input. Possible values include video, audio, or av.
   *
   * @remarks
   */
  type?: CreateMediaRequestType | undefined;
};

/**
 * Specifies the default access policy for domains.
 *
 * @remarks
 * If set to `allow`, all domains are allowed access unless otherwise specified in the `deny` lists.
 * If set to `deny`, all domains are denied access unless otherwise specified in the `allow` lists.
 */
export const DomainsDefaultPolicy = {
  Allow: "allow",
  Deny: "deny",
} as const;
/**
 * Specifies the default access policy for domains.
 *
 * @remarks
 * If set to `allow`, all domains are allowed access unless otherwise specified in the `deny` lists.
 * If set to `deny`, all domains are denied access unless otherwise specified in the `allow` lists.
 */
export type DomainsDefaultPolicy = ClosedEnum<typeof DomainsDefaultPolicy>;

export type CreateMediaRequestDomains = {
  /**
   * Specifies the default access policy for domains.
   *
   * @remarks
   * If set to `allow`, all domains are allowed access unless otherwise specified in the `deny` lists.
   * If set to `deny`, all domains are denied access unless otherwise specified in the `allow` lists.
   */
  defaultPolicy?: DomainsDefaultPolicy | undefined;
  /**
   * A list of domain names or patterns that are explicitly allowed access.
   *
   * @remarks
   * This list is only effective when the `defaultPolicy` is set to `deny`.
   */
  allow?: Array<string> | undefined;
  /**
   * A list of domain names or patterns that are explicitly denied access.
   *
   * @remarks
   * This list is only effective when the `defaultPolicy` is set to `allow`.
   */
  deny?: Array<string> | undefined;
};

/**
 * Specifies the default access policy for user agents (browsers, bots, etc.).
 *
 * @remarks
 * If set to `allow`, all user agents are allowed access unless otherwise specified in the `deny` lists.
 * If set to `deny`, all user agents are denied access unless otherwise specified in the `allow` lists.
 */
export const UserAgentsDefaultPolicy = {
  Allow: "allow",
  Deny: "deny",
} as const;
/**
 * Specifies the default access policy for user agents (browsers, bots, etc.).
 *
 * @remarks
 * If set to `allow`, all user agents are allowed access unless otherwise specified in the `deny` lists.
 * If set to `deny`, all user agents are denied access unless otherwise specified in the `allow` lists.
 */
export type UserAgentsDefaultPolicy = ClosedEnum<
  typeof UserAgentsDefaultPolicy
>;

export type CreateMediaRequestUserAgents = {
  /**
   * Specifies the default access policy for user agents (browsers, bots, etc.).
   *
   * @remarks
   * If set to `allow`, all user agents are allowed access unless otherwise specified in the `deny` lists.
   * If set to `deny`, all user agents are denied access unless otherwise specified in the `allow` lists.
   */
  defaultPolicy?: UserAgentsDefaultPolicy | undefined;
  /**
   * A list of user agents (identified by string names or patterns) that are explicitly allowed access.
   *
   * @remarks
   * This list is only effective when the `defaultPolicy` is set to `deny`.
   */
  allow?: Array<string> | undefined;
  /**
   * A list of user agents (identified by string names or patterns) that are explicitly denied access.
   *
   * @remarks
   * This list is only effective when the `defaultPolicy` is set to `allow`.
   */
  deny?: Array<string> | undefined;
};

export type CreateMediaRequestAccessRestrictions = {
  domains?: CreateMediaRequestDomains | undefined;
  userAgents?: CreateMediaRequestUserAgents | undefined;
};

export type CreateMediaRequest = {
  /**
   * Add one input object at a time. For example, first add a **VideoInput** object.   If you also need a watermark, click **Add item** again and select **WatermarkInput**.   Repeat this process for **AudioInput** or **SubtitleInput** as needed. For a complete explanation of how media uploads from URL and processing work, refer to the
   *
   * @remarks
   *         <a href="https://docs.fastpix.io/docs/video-on-demand-overview" target="_blank">FastPix Video on Demand Overview</a>.
   */
  inputs: Array<SubtitleInput | WatermarkInput | AudioInput | PullVideoInput>;
  /**
   * You can search for videos with specific key value pairs using metadata, when you tag a video in "key" : "value" pairs. Dynamic metadata allows you to define a key that allows any value pair. You can have maximum of 255 characters and upto 10 entries are allowed.
   *
   * @remarks
   */
  metadata?: { [k: string]: string } | undefined;
  /**
   * UUID of the DRM configuration to be used
   */
  drmConfigurationId?: string | undefined;
  /**
   * Title of the media file.
   */
  title?: string | undefined;
  /**
   * The unique identifier of the user who created this media.
   */
  creatorId?: string | undefined;
  /**
   * Generates subtitle files for audio/video files.
   *
   * @remarks
   */
  subtitles?: Subtitles | undefined;
  /**
   * Determines whether access to the streamed content is kept private or available to all.
   *
   * @remarks
   */
  accessPolicy?: CreateMediaRequestAccessPolicy | undefined;
  /**
   * "capped_4k": Generates an mp4 video file up to 4k resolution "audioOnly": Generates an m4a audio file of the media file "audioOnly,capped_4k": Generates both video and audio media files for offline viewing
   *
   * @remarks
   */
  mp4Support?: CreateMediaRequestMp4Support | undefined;
  /**
   * The sourceAccess parameter determines whether the original media file is accessible. Set to true to enable access or false to restrict it
   */
  sourceAccess?: boolean | undefined;
  /**
   * normalize volume of the audio track. This is available for pre-recorded content only.
   *
   * @remarks
   */
  optimizeAudio?: boolean | undefined;
  /**
   * The maximum resolution tier defines the highest quality at which your media is available.
   *
   * @remarks
   */
  maxResolution?: CreateMediaRequestMaxResolution | undefined;
  /**
   * The quality tier applied to the media.
   */
  mediaQuality?: CreateMediaRequestMediaQuality | undefined;
  summary?: Summary | undefined;
  /**
   * Enable or disable the chapters feature for the media. Set to `true` to enable chapters or `false` to disable.
   *
   * @remarks
   */
  chapters?: boolean | undefined;
  /**
   * Enable or disable named entity extraction. Set to `true` to enable or `false` to disable.
   *
   * @remarks
   */
  namedEntities?: boolean | undefined;
  moderation?: Moderation | undefined;
  accessRestrictions?: CreateMediaRequestAccessRestrictions | undefined;
};

/** @internal */
export type Input$Outbound =
  | SubtitleInput$Outbound
  | WatermarkInput$Outbound
  | AudioInput$Outbound
  | PullVideoInput$Outbound;

/** @internal */
export const Input$outboundSchema: z.ZodMiniType<Input$Outbound, Input> =
  smartUnion([
    SubtitleInput$outboundSchema,
    WatermarkInput$outboundSchema,
    AudioInput$outboundSchema,
    PullVideoInput$outboundSchema,
  ]);

export function inputToJSON(input: Input): string {
  return JSON.stringify(Input$outboundSchema.parse(input));
}

/** @internal */
export const CreateMediaRequestLanguageCode$outboundSchema: z.ZodMiniEnum<
  typeof CreateMediaRequestLanguageCode
> = z.enum(CreateMediaRequestLanguageCode);

/** @internal */
export type Subtitles$Outbound = {
  languageName?: string | undefined;
  metadata?: { [k: string]: string } | undefined;
  languageCode?: string | undefined;
};

/** @internal */
export const Subtitles$outboundSchema: z.ZodMiniType<
  Subtitles$Outbound,
  Subtitles
> = z.object({
  languageName: z.optional(z.string()),
  metadata: z.optional(z.record(z.string(), z.string())),
  languageCode: z.optional(CreateMediaRequestLanguageCode$outboundSchema),
});

export function subtitlesToJSON(subtitles: Subtitles): string {
  return JSON.stringify(Subtitles$outboundSchema.parse(subtitles));
}

/** @internal */
export const CreateMediaRequestAccessPolicy$outboundSchema: z.ZodMiniEnum<
  typeof CreateMediaRequestAccessPolicy
> = z.enum(CreateMediaRequestAccessPolicy);

/** @internal */
export const CreateMediaRequestMp4Support$outboundSchema: z.ZodMiniEnum<
  typeof CreateMediaRequestMp4Support
> = z.enum(CreateMediaRequestMp4Support);

/** @internal */
export const CreateMediaRequestMaxResolution$outboundSchema: z.ZodMiniEnum<
  typeof CreateMediaRequestMaxResolution
> = z.enum(CreateMediaRequestMaxResolution);

/** @internal */
export const CreateMediaRequestMediaQuality$outboundSchema: z.ZodMiniEnum<
  typeof CreateMediaRequestMediaQuality
> = z.enum(CreateMediaRequestMediaQuality);

/** @internal */
export type Summary$Outbound = {
  generate?: boolean | undefined;
  summaryLength?: number | undefined;
};

/** @internal */
export const Summary$outboundSchema: z.ZodMiniType<Summary$Outbound, Summary> =
  z.object({
    generate: z.optional(z.boolean()),
    summaryLength: z.optional(z.int()),
  });

export function summaryToJSON(summary: Summary): string {
  return JSON.stringify(Summary$outboundSchema.parse(summary));
}

/** @internal */
export const CreateMediaRequestType$outboundSchema: z.ZodMiniEnum<
  typeof CreateMediaRequestType
> = z.enum(CreateMediaRequestType);

/** @internal */
export type Moderation$Outbound = {
  type?: string | undefined;
};

/** @internal */
export const Moderation$outboundSchema: z.ZodMiniType<
  Moderation$Outbound,
  Moderation
> = z.object({
  type: z.optional(CreateMediaRequestType$outboundSchema),
});

export function moderationToJSON(moderation: Moderation): string {
  return JSON.stringify(Moderation$outboundSchema.parse(moderation));
}

/** @internal */
export const DomainsDefaultPolicy$outboundSchema: z.ZodMiniEnum<
  typeof DomainsDefaultPolicy
> = z.enum(DomainsDefaultPolicy);

/** @internal */
export type CreateMediaRequestDomains$Outbound = {
  defaultPolicy?: string | undefined;
  allow?: Array<string> | undefined;
  deny?: Array<string> | undefined;
};

/** @internal */
export const CreateMediaRequestDomains$outboundSchema: z.ZodMiniType<
  CreateMediaRequestDomains$Outbound,
  CreateMediaRequestDomains
> = z.object({
  defaultPolicy: z.optional(DomainsDefaultPolicy$outboundSchema),
  allow: z.optional(z.array(z.string())),
  deny: z.optional(z.array(z.string())),
});

export function createMediaRequestDomainsToJSON(
  createMediaRequestDomains: CreateMediaRequestDomains,
): string {
  return JSON.stringify(
    CreateMediaRequestDomains$outboundSchema.parse(createMediaRequestDomains),
  );
}

/** @internal */
export const UserAgentsDefaultPolicy$outboundSchema: z.ZodMiniEnum<
  typeof UserAgentsDefaultPolicy
> = z.enum(UserAgentsDefaultPolicy);

/** @internal */
export type CreateMediaRequestUserAgents$Outbound = {
  defaultPolicy?: string | undefined;
  allow?: Array<string> | undefined;
  deny?: Array<string> | undefined;
};

/** @internal */
export const CreateMediaRequestUserAgents$outboundSchema: z.ZodMiniType<
  CreateMediaRequestUserAgents$Outbound,
  CreateMediaRequestUserAgents
> = z.object({
  defaultPolicy: z.optional(UserAgentsDefaultPolicy$outboundSchema),
  allow: z.optional(z.array(z.string())),
  deny: z.optional(z.array(z.string())),
});

export function createMediaRequestUserAgentsToJSON(
  createMediaRequestUserAgents: CreateMediaRequestUserAgents,
): string {
  return JSON.stringify(
    CreateMediaRequestUserAgents$outboundSchema.parse(
      createMediaRequestUserAgents,
    ),
  );
}

/** @internal */
export type CreateMediaRequestAccessRestrictions$Outbound = {
  domains?: CreateMediaRequestDomains$Outbound | undefined;
  userAgents?: CreateMediaRequestUserAgents$Outbound | undefined;
};

/** @internal */
export const CreateMediaRequestAccessRestrictions$outboundSchema: z.ZodMiniType<
  CreateMediaRequestAccessRestrictions$Outbound,
  CreateMediaRequestAccessRestrictions
> = z.object({
  domains: z.optional(z.lazy(() => CreateMediaRequestDomains$outboundSchema)),
  userAgents: z.optional(
    z.lazy(() => CreateMediaRequestUserAgents$outboundSchema),
  ),
});

export function createMediaRequestAccessRestrictionsToJSON(
  createMediaRequestAccessRestrictions: CreateMediaRequestAccessRestrictions,
): string {
  return JSON.stringify(
    CreateMediaRequestAccessRestrictions$outboundSchema.parse(
      createMediaRequestAccessRestrictions,
    ),
  );
}

/** @internal */
export type CreateMediaRequest$Outbound = {
  inputs: Array<
    | SubtitleInput$Outbound
    | WatermarkInput$Outbound
    | AudioInput$Outbound
    | PullVideoInput$Outbound
  >;
  metadata?: { [k: string]: string } | undefined;
  drmConfigurationId?: string | undefined;
  title?: string | undefined;
  creatorId?: string | undefined;
  subtitles?: Subtitles$Outbound | undefined;
  accessPolicy: string;
  mp4Support?: string | undefined;
  sourceAccess?: boolean | undefined;
  optimizeAudio?: boolean | undefined;
  maxResolution: string;
  mediaQuality: string;
  summary?: Summary$Outbound | undefined;
  chapters?: boolean | undefined;
  namedEntities?: boolean | undefined;
  moderation?: Moderation$Outbound | undefined;
  accessRestrictions?:
    | CreateMediaRequestAccessRestrictions$Outbound
    | undefined;
};

/** @internal */
export const CreateMediaRequest$outboundSchema: z.ZodMiniType<
  CreateMediaRequest$Outbound,
  CreateMediaRequest
> = z.object({
  inputs: z.array(
    smartUnion([
      SubtitleInput$outboundSchema,
      WatermarkInput$outboundSchema,
      AudioInput$outboundSchema,
      PullVideoInput$outboundSchema,
    ]),
  ),
  metadata: z.optional(z.record(z.string(), z.string())),
  drmConfigurationId: z.optional(z.string()),
  title: z.optional(z.string()),
  creatorId: z.optional(z.string()),
  subtitles: z.optional(z.lazy(() => Subtitles$outboundSchema)),
  accessPolicy: z._default(
    CreateMediaRequestAccessPolicy$outboundSchema,
    "public",
  ),
  mp4Support: z.optional(CreateMediaRequestMp4Support$outboundSchema),
  sourceAccess: z.optional(z.boolean()),
  optimizeAudio: z.optional(z.boolean()),
  maxResolution: z._default(
    CreateMediaRequestMaxResolution$outboundSchema,
    "1080p",
  ),
  mediaQuality: z._default(
    CreateMediaRequestMediaQuality$outboundSchema,
    "standard",
  ),
  summary: z.optional(z.lazy(() => Summary$outboundSchema)),
  chapters: z.optional(z.boolean()),
  namedEntities: z.optional(z.boolean()),
  moderation: z.optional(z.lazy(() => Moderation$outboundSchema)),
  accessRestrictions: z.optional(
    z.lazy(() => CreateMediaRequestAccessRestrictions$outboundSchema),
  ),
});

export function createMediaRequestToJSON(
  createMediaRequest: CreateMediaRequest,
): string {
  return JSON.stringify(
    CreateMediaRequest$outboundSchema.parse(createMediaRequest),
  );
}
