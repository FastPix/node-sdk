/*
* This file is auto-generated.
 * Do not edit this file manually.
 * Your changes will be overwritten during the next generation.
 */

import * as z from "zod/v4-mini";
import { ClosedEnum } from "../types/enums.js";

/**
 * Type of overlay (currently only supports "audio").
 */
export const AudioInputType = {
  Audio: "audio",
} as const;
/**
 * Type of overlay (currently only supports "audio").
 */
export type AudioInputType = ClosedEnum<typeof AudioInputType>;

export type ImposeTrack = {
  /**
   * URL of the audio track to impose on the video.
   */
  url?: string | undefined;
  /**
   * Start time (in seconds) of the imposed audio in the video.
   */
  startTime?: number | undefined;
  /**
   * End time (in seconds) of the imposed audio in the video.
   */
  endTime?: number | undefined;
  /**
   * Level of fade-in effect (in seconds) at the start of the imposed audio.
   */
  fadeInLevel?: number | undefined;
  /**
   * Level of fade-out effect (in seconds) at the end of the imposed audio.
   */
  fadeOutLevel?: number | undefined;
};

export type AudioInput = {
  /**
   * Type of overlay (currently only supports "audio").
   */
  type: AudioInputType;
  /**
   * URL of the audio track to replace the existing audio in the video.
   */
  swapTrackUrl: string;
  /**
   * List of additional audio tracks to overlay on the video.
   */
  imposeTracks?: Array<ImposeTrack> | undefined;
};

/** @internal */
export const AudioInputType$outboundSchema: z.ZodMiniEnum<
  typeof AudioInputType
> = z.enum(AudioInputType);

/** @internal */
export type ImposeTrack$Outbound = {
  url?: string | undefined;
  startTime?: number | undefined;
  endTime?: number | undefined;
  fadeInLevel?: number | undefined;
  fadeOutLevel?: number | undefined;
};

/** @internal */
export const ImposeTrack$outboundSchema: z.ZodMiniType<
  ImposeTrack$Outbound,
  ImposeTrack
> = z.object({
  url: z.optional(z.string()),
  startTime: z.optional(z.int()),
  endTime: z.optional(z.int()),
  fadeInLevel: z.optional(z.int()),
  fadeOutLevel: z.optional(z.int()),
});

export function imposeTrackToJSON(imposeTrack: ImposeTrack): string {
  return JSON.stringify(ImposeTrack$outboundSchema.parse(imposeTrack));
}

/** @internal */
export type AudioInput$Outbound = {
  type: string;
  swapTrackUrl: string;
  imposeTracks?: Array<ImposeTrack$Outbound> | undefined;
};

/** @internal */
export const AudioInput$outboundSchema: z.ZodMiniType<
  AudioInput$Outbound,
  AudioInput
> = z.object({
  type: AudioInputType$outboundSchema,
  swapTrackUrl: z.string(),
  imposeTracks: z.optional(z.array(z.lazy(() => ImposeTrack$outboundSchema))),
});

export function audioInputToJSON(audioInput: AudioInput): string {
  return JSON.stringify(AudioInput$outboundSchema.parse(audioInput));
}
