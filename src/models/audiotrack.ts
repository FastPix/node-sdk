/*
* This file is auto-generated.
 * Do not edit this file manually.
 * Your changes will be overwritten during the next generation.
 */

import * as z from "zod/v4-mini";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

/**
 * Defines the type of input track.
 */
export const AudioTrackType = {
  Audio: "audio",
} as const;
/**
 * Defines the type of input track.
 */
export type AudioTrackType = ClosedEnum<typeof AudioTrackType>;

/**
 * A media consists of different media tracks, like video, audio, and subtitle, all combined.
 */
export type AudioTrack = {
  /**
   * FastPix generates a unique identifier for each track.
   */
  id?: string | undefined;
  /**
   * Defines the type of input track.
   */
  type?: AudioTrackType | undefined;
  /**
   * Indicates the current state of the track. 'available' means the track has been processed successfully and is ready to be used or played.
   */
  status?: string | undefined;
  /**
   * Name of the language in which the subtitles will be generated.
   *
   * @remarks
   */
  languageName?: string | undefined;
  /**
   * Language codes are concise, standardized symbols that denote languages, utilizing either two or three characters for identification. The language code must be compliant with the BCP 47 standard to ensure compatibility. (for text only).
   *
   * @remarks
   */
  languageCode?: string | undefined;
};

/** @internal */
export const AudioTrackType$inboundSchema: z.ZodMiniEnum<
  typeof AudioTrackType
> = z.enum(AudioTrackType);

/** @internal */
export const AudioTrack$inboundSchema: z.ZodMiniType<AudioTrack, unknown> = z
  .object({
    id: types.optional(types.string()),
    type: types.optional(AudioTrackType$inboundSchema),
    status: types.optional(types.string()),
    languageName: types.optional(types.string()),
    languageCode: types.optional(types.string()),
  });

export function audioTrackFromJSON(
  jsonString: string,
): SafeParseResult<AudioTrack, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AudioTrack$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AudioTrack' from JSON`,
  );
}
