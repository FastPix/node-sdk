/*
* This file is auto-generated.
 * Do not edit this file manually.
 * Your changes will be overwritten during the next generation.
 */

import * as z from "zod/v4-mini";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  UnusedUploadsPlaybackId,
  UnusedUploadsPlaybackId$inboundSchema,
} from "./unuseduploadsplaybackid.js";

/**
 * The quality tier applied to the media.
 */
export const UnusedDirectUploadResponseMediaQuality = {
  Standard: "standard",
  Pro: "pro",
  Premium: "premium",
} as const;
/**
 * The quality tier applied to the media.
 */
export type UnusedDirectUploadResponseMediaQuality = OpenEnum<
  typeof UnusedDirectUploadResponseMediaQuality
>;

export type UnusedDirectUploadResponse = {
  playbackIds?: Array<UnusedUploadsPlaybackId> | undefined;
  /**
   * You can search for videos with specific key value pairs using metadata, when you tag a video in "key" : "value" pairs. Dynamic metadata allows you to define a key that allows any value pair. You can have maximum of 255 characters and upto 10 entries are allowed.
   *
   * @remarks
   */
  metadata?: { [k: string]: string } | undefined;
  /**
   * The quality tier applied to the media.
   */
  mediaQuality?: UnusedDirectUploadResponseMediaQuality | undefined;
  /**
   * The sourceAccess parameter determines whether the original media file is accessible. Set to true to enable access or false to restrict it.
   *
   * @remarks
   */
  sourceAccess?: boolean | undefined;
  /**
   * Enhance the quality and volume of the audio track. This is available for pre-recorded content only.
   *
   * @remarks
   */
  optimizeAudio?: boolean | undefined;
};

/** @internal */
export const UnusedDirectUploadResponseMediaQuality$inboundSchema:
  z.ZodMiniType<UnusedDirectUploadResponseMediaQuality, unknown> = openEnums
    .inboundSchema(UnusedDirectUploadResponseMediaQuality);

/** @internal */
export const UnusedDirectUploadResponse$inboundSchema: z.ZodMiniType<
  UnusedDirectUploadResponse,
  unknown
> = z.object({
  playbackIds: types.optional(z.array(UnusedUploadsPlaybackId$inboundSchema)),
  metadata: types.optional(z.record(z.string(), types.string())),
  mediaQuality: types.optional(
    UnusedDirectUploadResponseMediaQuality$inboundSchema,
  ),
  sourceAccess: types.optional(types.boolean()),
  optimizeAudio: types.optional(types.boolean()),
});

export function unusedDirectUploadResponseFromJSON(
  jsonString: string,
): SafeParseResult<UnusedDirectUploadResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UnusedDirectUploadResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UnusedDirectUploadResponse' from JSON`,
  );
}
