/*
* This file is auto-generated.
 * Do not edit this file manually.
 * Your changes will be overwritten during the next generation.
 */

import * as z from "zod/v4-mini";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smartUnion.js";
import { AudioTrack, AudioTrack$inboundSchema } from "./audiotrack.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import { PlaybackId, PlaybackId$inboundSchema } from "./playbackid.js";
import { SubtitleTrack, SubtitleTrack$inboundSchema } from "./subtitletrack.js";
import { VideoTrack, VideoTrack$inboundSchema } from "./videotrack.js";

/**
 * The maximum resolution specified by the user for the media.
 */
export const LiveMediaClipsMaxResolution = {
  TwoThousandOneHundredAndSixtyp: "2160p",
  OneThousandFourHundredAndFortyp: "1440p",
  OneThousandAndEightyp: "1080p",
  SevenHundredAndTwentyp: "720p",
  FourHundredAndEightyp: "480p",
} as const;
/**
 * The maximum resolution specified by the user for the media.
 */
export type LiveMediaClipsMaxResolution = OpenEnum<
  typeof LiveMediaClipsMaxResolution
>;

/**
 * The actual resolution of the uploaded media. This represents the native quality of the source media.
 */
export const LiveMediaClipsSourceResolution = {
  TwoThousandOneHundredAndSixtyp: "2160p",
  OneThousandFourHundredAndFortyp: "1440p",
  OneThousandAndEightyp: "1080p",
  SevenHundredAndTwentyp: "720p",
  FourHundredAndEightyp: "480p",
} as const;
/**
 * The actual resolution of the uploaded media. This represents the native quality of the source media.
 */
export type LiveMediaClipsSourceResolution = OpenEnum<
  typeof LiveMediaClipsSourceResolution
>;

/**
 * Determines the media's status, which can be one of the possible values.
 */
export const LiveMediaClipsStatus = {
  Created: "Created",
  Downloading: "Downloading",
  Downloaded: "Downloaded",
  Validating: "Validating",
  InQueue: "In Queue",
  Processing: "Processing",
  Ready: "Ready",
  Failed: "Failed",
} as const;
/**
 * Determines the media's status, which can be one of the possible values.
 */
export type LiveMediaClipsStatus = OpenEnum<typeof LiveMediaClipsStatus>;

export type LiveMediaClipsTrack = VideoTrack | AudioTrack | SubtitleTrack;

export type LiveMediaClips = {
  /**
   * A video thumbnail is a still image that acts as the preview image for your video.
   */
  thumbnail?: string | null | undefined;
  /**
   * The unique identifier assigned to the media when created. The value must be a valid UUID.
   */
  id?: string | undefined;
  /**
   * A unique identifier is generated by FastPix for the workspace.
   */
  workspaceId?: string | undefined;
  /**
   * The ID of the livestream for which the clips were created.
   */
  streamId?: string | undefined;
  /**
   * The unique identifier of the user who created this media.
   */
  creatorId?: string | null | undefined;
  /**
   * Title of the media file.
   */
  title?: string | null | undefined;
  /**
   * The maximum resolution specified by the user for the media.
   */
  maxResolution?: LiveMediaClipsMaxResolution | undefined;
  /**
   * The actual resolution of the uploaded media. This represents the native quality of the source media.
   */
  sourceResolution?: LiveMediaClipsSourceResolution | undefined;
  /**
   * Determines the media's status, which can be one of the possible values.
   */
  status?: LiveMediaClipsStatus | undefined;
  /**
   * The sourceAccess parameter determines whether the original media file is accessible. Set to true to enable access or false to restrict it.
   */
  sourceAccess?: boolean | undefined;
  /**
   * A collection of Playback ID objects utilized for crafting HLS playback URLs.
   */
  playbackIds?: Array<PlaybackId> | undefined;
  /**
   * A media consists of different media tracks, like video, audio, and subtitle, all combined.
   */
  tracks?: Array<VideoTrack | AudioTrack | SubtitleTrack> | undefined;
  /**
   * Indicates whether the media contains only audio (no video track).
   */
  isAudioOnly?: boolean | null | undefined;
  /**
   * Indicates whether subtitles are available for the media.
   */
  subtitleAvailable?: boolean | null | undefined;
  /**
   * The length of the media in seconds, with a maximum allowed duration of 12 hours per individual media.
   */
  duration?: string | undefined;
  /**
   * The aspect ratio of a video is a value that describes the relative shape of a video based on its width and height.
   */
  aspectRatio?: string | null | undefined;
  /**
   * Time the media was created, defined as a localDateTime (UTC Time).
   */
  createdAt?: Date | undefined;
  /**
   * Time the media was updated, defined as a localDateTime (UTC Time).
   */
  updatedAt?: Date | undefined;
};

/** @internal */
export const LiveMediaClipsMaxResolution$inboundSchema: z.ZodMiniType<
  LiveMediaClipsMaxResolution,
  unknown
> = openEnums.inboundSchema(LiveMediaClipsMaxResolution);

/** @internal */
export const LiveMediaClipsSourceResolution$inboundSchema: z.ZodMiniType<
  LiveMediaClipsSourceResolution,
  unknown
> = openEnums.inboundSchema(LiveMediaClipsSourceResolution);

/** @internal */
export const LiveMediaClipsStatus$inboundSchema: z.ZodMiniType<
  LiveMediaClipsStatus,
  unknown
> = openEnums.inboundSchema(LiveMediaClipsStatus);

/** @internal */
export const LiveMediaClipsTrack$inboundSchema: z.ZodMiniType<
  LiveMediaClipsTrack,
  unknown
> = smartUnion([
  VideoTrack$inboundSchema,
  AudioTrack$inboundSchema,
  SubtitleTrack$inboundSchema,
]);

export function liveMediaClipsTrackFromJSON(
  jsonString: string,
): SafeParseResult<LiveMediaClipsTrack, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LiveMediaClipsTrack$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LiveMediaClipsTrack' from JSON`,
  );
}

/** @internal */
export const LiveMediaClips$inboundSchema: z.ZodMiniType<
  LiveMediaClips,
  unknown
> = z.object({
  thumbnail: z.optional(z.nullable(types.string())),
  id: types.optional(types.string()),
  workspaceId: types.optional(types.string()),
  streamId: types.optional(types.string()),
  creatorId: z.optional(z.nullable(types.string())),
  title: z.optional(z.nullable(types.string())),
  maxResolution: z._default(LiveMediaClipsMaxResolution$inboundSchema, "1080p"),
  sourceResolution: z._default(
    LiveMediaClipsSourceResolution$inboundSchema,
    "1080p",
  ),
  status: types.optional(LiveMediaClipsStatus$inboundSchema),
  sourceAccess: types.optional(types.boolean()),
  playbackIds: types.optional(z.array(PlaybackId$inboundSchema)),
  tracks: types.optional(
    z.array(
      smartUnion([
        VideoTrack$inboundSchema,
        AudioTrack$inboundSchema,
        SubtitleTrack$inboundSchema,
      ]),
    ),
  ),
  isAudioOnly: z.optional(z.nullable(types.boolean())),
  subtitleAvailable: z.optional(z.nullable(types.boolean())),
  duration: types.optional(types.string()),
  aspectRatio: z.optional(z.nullable(types.string())),
  createdAt: types.optional(types.date()),
  updatedAt: types.optional(types.date()),
});

export function liveMediaClipsFromJSON(
  jsonString: string,
): SafeParseResult<LiveMediaClips, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LiveMediaClips$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LiveMediaClips' from JSON`,
  );
}
