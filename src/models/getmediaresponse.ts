/*
* This file is auto-generated.
 * Do not edit this file manually.
 * Your changes will be overwritten during the next generation.
 */

import * as z from "zod/v4-mini";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smartUnion.js";
import {
  AiResponseRecord,
  AiResponseRecord$inboundSchema,
} from "./airesponserecord.js";
import {
  AiSummaryRecord,
  AiSummaryRecord$inboundSchema,
} from "./aisummaryrecord.js";
import { AudioTrack, AudioTrack$inboundSchema } from "./audiotrack.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import { PlaybackId, PlaybackId$inboundSchema } from "./playbackid.js";
import { SubtitleTrack, SubtitleTrack$inboundSchema } from "./subtitletrack.js";
import {
  TracksSubtitles,
  TracksSubtitles$inboundSchema,
} from "./trackssubtitles.js";
import { VideoTrack, VideoTrack$inboundSchema } from "./videotrack.js";

/**
 * The quality tier applied to the media.
 */
export const GetMediaResponseMediaQuality = {
  Standard: "standard",
  Pro: "pro",
  Premium: "premium",
} as const;
/**
 * The quality tier applied to the media.
 */
export type GetMediaResponseMediaQuality = OpenEnum<
  typeof GetMediaResponseMediaQuality
>;

/**
 * The maximum resolution specified by the user for the media.
 */
export const GetMediaResponseMaxResolution = {
  TwoThousandOneHundredAndSixtyp: "2160p",
  OneThousandFourHundredAndFortyp: "1440p",
  OneThousandAndEightyp: "1080p",
  SevenHundredAndTwentyp: "720p",
  FourHundredAndEightyp: "480p",
} as const;
/**
 * The maximum resolution specified by the user for the media.
 */
export type GetMediaResponseMaxResolution = OpenEnum<
  typeof GetMediaResponseMaxResolution
>;

/**
 * The actual resolution of the uploaded media. This represents the native quality of the source media.
 */
export const GetMediaResponseSourceResolution = {
  TwoThousandOneHundredAndSixtyp: "2160p",
  OneThousandFourHundredAndFortyp: "1440p",
  OneThousandAndEightyp: "1080p",
  SevenHundredAndTwentyp: "720p",
  FourHundredAndEightyp: "480p",
} as const;
/**
 * The actual resolution of the uploaded media. This represents the native quality of the source media.
 */
export type GetMediaResponseSourceResolution = OpenEnum<
  typeof GetMediaResponseSourceResolution
>;

/**
 * Determines the media's status, which can be one of the possible values.
 */
export const GetMediaResponseStatus = {
  Created: "Created",
  Downloading: "Downloading",
  Downloaded: "Downloaded",
  Validating: "Validating",
  InQueue: "In Queue",
  Processing: "Processing",
  Ready: "Ready",
  Failed: "Failed",
} as const;
/**
 * Determines the media's status, which can be one of the possible values.
 */
export type GetMediaResponseStatus = OpenEnum<typeof GetMediaResponseStatus>;

/**
 * Determines the type of MP4 support for the media.
 *
 * @remarks
 * - **none**: Disables MP4 support.
 * - **capped_4k**: Enables MP4 downloads with resolutions up to 4K.
 * - **audioOnly**: Provides an MP4 stream containing only the audio.
 * - **audioOnly,capped_4k**: Enables both MP4 video downloads (up to 4K) and an audio-only stream.
 */
export const GetMediaResponseMp4Support = {
  None: "none",
  Capped4k: "capped_4k",
  AudioOnly: "audioOnly",
  AudioOnlyCapped4k: "audioOnly,capped_4k",
} as const;
/**
 * Determines the type of MP4 support for the media.
 *
 * @remarks
 * - **none**: Disables MP4 support.
 * - **capped_4k**: Enables MP4 downloads with resolutions up to 4K.
 * - **audioOnly**: Provides an MP4 stream containing only the audio.
 * - **audioOnly,capped_4k**: Enables both MP4 video downloads (up to 4K) and an audio-only stream.
 */
export type GetMediaResponseMp4Support = OpenEnum<
  typeof GetMediaResponseMp4Support
>;

export type GetMediaResponseTrack = VideoTrack | AudioTrack | SubtitleTrack;

export type GetMediaResponse = {
  /**
   * A video thumbnail is a still image that acts as the preview image for your video.
   */
  thumbnail?: string | null | undefined;
  /**
   * The unique identifier assigned to the media when created. The value must be a valid UUID.
   */
  id?: string | undefined;
  /**
   * The source media ID if this media was created from another media (for example, as a clip).
   */
  sourceMediaId?: string | null | undefined;
  /**
   * A unique identifier is generated by FastPix for the workspace.
   */
  workspaceId?: string | undefined;
  /**
   * The ID of the livestream for which the clips were created.
   */
  streamId?: string | undefined;
  /**
   * You can search for videos with specific key value pairs using metadata, when you tag a video in "key" : "value" pairs. Dynamic metadata allows you to define a key that allows any value pair. You can have maximum of 255 characters and upto 10 entries are allowed.
   *
   * @remarks
   */
  metadata?: { [k: string]: string } | null | undefined;
  /**
   * The quality tier applied to the media.
   */
  mediaQuality?: GetMediaResponseMediaQuality | undefined;
  /**
   * The unique identifier of the user who created this media.
   */
  creatorId?: string | null | undefined;
  /**
   * Title of the media file.
   */
  title?: string | null | undefined;
  /**
   * The maximum resolution specified by the user for the media.
   */
  maxResolution?: GetMediaResponseMaxResolution | undefined;
  /**
   * The actual resolution of the uploaded media. This represents the native quality of the source media.
   */
  sourceResolution?: GetMediaResponseSourceResolution | undefined;
  /**
   * Determines the media's status, which can be one of the possible values.
   */
  status?: GetMediaResponseStatus | undefined;
  /**
   * Determines the type of MP4 support for the media.
   *
   * @remarks
   * - **none**: Disables MP4 support.
   * - **capped_4k**: Enables MP4 downloads with resolutions up to 4K.
   * - **audioOnly**: Provides an MP4 stream containing only the audio.
   * - **audioOnly,capped_4k**: Enables both MP4 video downloads (up to 4K) and an audio-only stream.
   */
  mp4Support?: GetMediaResponseMp4Support | null | undefined;
  /**
   * The sourceAccess parameter determines whether the original media file is accessible. Set to true to enable access or false to restrict it.
   */
  sourceAccess?: boolean | null | undefined;
  /**
   * A collection of Playback ID objects utilized for crafting HLS playback URLs.
   */
  playbackIds?: Array<PlaybackId> | undefined;
  /**
   * A media consists of different media tracks, like video, audio, and subtitle, all combined.
   */
  tracks?: Array<VideoTrack | AudioTrack | SubtitleTrack> | undefined;
  /**
   * List of generated subtitle tracks associated with the media.
   */
  generatedSubtitles?: Array<TracksSubtitles> | null | undefined;
  /**
   * Represents an AI response record containing status and data for AI-generated features like summary, chapters, named entities, or moderation.
   */
  summary?: AiSummaryRecord | undefined;
  /**
   * Represents an AI response record containing status and data for AI-generated features like summary, chapters, named entities, or moderation.
   */
  chapters?: AiResponseRecord | undefined;
  /**
   * Represents an AI response record containing status and data for AI-generated features like summary, chapters, named entities, or moderation.
   */
  namedEntities?: AiResponseRecord | undefined;
  /**
   * Represents an AI response record containing status and data for AI-generated features like summary, chapters, named entities, or moderation.
   */
  moderation?: AiResponseRecord | undefined;
  /**
   * Indicates whether the media contains only audio (no video track).
   */
  isAudioOnly?: boolean | null | undefined;
  /**
   * Indicates whether subtitles are available for the media.
   */
  subtitleAvailable?: boolean | null | undefined;
  /**
   * The length of the media in seconds, with a maximum allowed duration of 12 hours per individual media.
   */
  duration?: string | undefined;
  /**
   * Frame rate quantifies the speed at which frames are displayed per second. It represents the range of frames available for a specific track. The indeterminable frame rate of the input file is indicated by a value of -1.
   */
  frameRate?: string | null | undefined;
  /**
   * The aspect ratio of a video is a value that describes the relative shape of a video based on its width and height.
   */
  aspectRatio?: string | null | undefined;
  /**
   * Time the media was created, defined as a localDateTime (UTC Time).
   */
  createdAt?: Date | undefined;
  /**
   * Time the media was updated, defined as a localDateTime (UTC Time).
   */
  updatedAt?: Date | undefined;
};

/** @internal */
export const GetMediaResponseMediaQuality$inboundSchema: z.ZodMiniType<
  GetMediaResponseMediaQuality,
  unknown
> = openEnums.inboundSchema(GetMediaResponseMediaQuality);

/** @internal */
export const GetMediaResponseMaxResolution$inboundSchema: z.ZodMiniType<
  GetMediaResponseMaxResolution,
  unknown
> = openEnums.inboundSchema(GetMediaResponseMaxResolution);

/** @internal */
export const GetMediaResponseSourceResolution$inboundSchema: z.ZodMiniType<
  GetMediaResponseSourceResolution,
  unknown
> = openEnums.inboundSchema(GetMediaResponseSourceResolution);

/** @internal */
export const GetMediaResponseStatus$inboundSchema: z.ZodMiniType<
  GetMediaResponseStatus,
  unknown
> = openEnums.inboundSchema(GetMediaResponseStatus);

/** @internal */
export const GetMediaResponseMp4Support$inboundSchema: z.ZodMiniType<
  GetMediaResponseMp4Support,
  unknown
> = openEnums.inboundSchema(GetMediaResponseMp4Support);

/** @internal */
export const GetMediaResponseTrack$inboundSchema: z.ZodMiniType<
  GetMediaResponseTrack,
  unknown
> = smartUnion([
  VideoTrack$inboundSchema,
  AudioTrack$inboundSchema,
  SubtitleTrack$inboundSchema,
]);

export function getMediaResponseTrackFromJSON(
  jsonString: string,
): SafeParseResult<GetMediaResponseTrack, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetMediaResponseTrack$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetMediaResponseTrack' from JSON`,
  );
}

/** @internal */
export const GetMediaResponse$inboundSchema: z.ZodMiniType<
  GetMediaResponse,
  unknown
> = z.object({
  thumbnail: z.optional(z.nullable(types.string())),
  id: types.optional(types.string()),
  sourceMediaId: z.optional(z.nullable(types.string())),
  workspaceId: types.optional(types.string()),
  streamId: types.optional(types.string()),
  metadata: z.optional(z.nullable(z.record(z.string(), types.string()))),
  mediaQuality: types.optional(GetMediaResponseMediaQuality$inboundSchema),
  creatorId: z.optional(z.nullable(types.string())),
  title: z.optional(z.nullable(types.string())),
  maxResolution: z._default(
    GetMediaResponseMaxResolution$inboundSchema,
    "1080p",
  ),
  sourceResolution: z._default(
    GetMediaResponseSourceResolution$inboundSchema,
    "1080p",
  ),
  status: types.optional(GetMediaResponseStatus$inboundSchema),
  mp4Support: z.optional(z.nullable(GetMediaResponseMp4Support$inboundSchema)),
  sourceAccess: z.optional(z.nullable(types.boolean())),
  playbackIds: types.optional(z.array(PlaybackId$inboundSchema)),
  tracks: types.optional(
    z.array(
      smartUnion([
        VideoTrack$inboundSchema,
        AudioTrack$inboundSchema,
        SubtitleTrack$inboundSchema,
      ]),
    ),
  ),
  generatedSubtitles: z.optional(
    z.nullable(z.array(TracksSubtitles$inboundSchema)),
  ),
  summary: types.optional(AiSummaryRecord$inboundSchema),
  chapters: types.optional(AiResponseRecord$inboundSchema),
  namedEntities: types.optional(AiResponseRecord$inboundSchema),
  moderation: types.optional(AiResponseRecord$inboundSchema),
  isAudioOnly: z.optional(z.nullable(types.boolean())),
  subtitleAvailable: z.optional(z.nullable(types.boolean())),
  duration: types.optional(types.string()),
  frameRate: z.optional(z.nullable(types.string())),
  aspectRatio: z.optional(z.nullable(types.string())),
  createdAt: types.optional(types.date()),
  updatedAt: types.optional(types.date()),
});

export function getMediaResponseFromJSON(
  jsonString: string,
): SafeParseResult<GetMediaResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetMediaResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetMediaResponse' from JSON`,
  );
}
