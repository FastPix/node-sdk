/*
* This file is auto-generated.
 * Do not edit this file manually.
 * Your changes will be overwritten during the next generation.
 */

import * as z from "zod/v4-mini";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { smartUnion } from "../../types/smartUnion.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import * as models from "../index.js";

/**
 * Determines if access to the streamed content is kept private, drm or available to all.
 */
export const DirectUploadVideoMediaAccessPolicy = {
  Public: "public",
  Private: "private",
  Drm: "drm",
} as const;
/**
 * Determines if access to the streamed content is kept private, drm or available to all.
 */
export type DirectUploadVideoMediaAccessPolicy = ClosedEnum<
  typeof DirectUploadVideoMediaAccessPolicy
>;

export type Input =
  | models.SubtitleInput
  | models.WatermarkInput
  | models.AudioInput
  | models.VideoInput;

/**
 * Language codes (BCP 47 compliant) used for text files.
 *
 * @remarks
 */
export const LanguageCode = {
  En: "en",
  It: "it",
  Pl: "pl",
  Es: "es",
  Fr: "fr",
  Ru: "ru",
  Nl: "nl",
} as const;
/**
 * Language codes (BCP 47 compliant) used for text files.
 *
 * @remarks
 */
export type LanguageCode = ClosedEnum<typeof LanguageCode>;

/**
 * Generates subtitle files for audio/video files.
 *
 * @remarks
 */
export type Subtitles = {
  /**
   * Name of the language for the subtitles.
   */
  languageName?: string | undefined;
  /**
   * "Tag a video in "key" : "value" pairs for searchable metadata. Maximum 10 entries, 255 characters each."
   *
   * @remarks
   */
  metadata?: { [k: string]: string } | undefined;
  /**
   * Language codes (BCP 47 compliant) used for text files.
   *
   * @remarks
   */
  languageCode?: LanguageCode | undefined;
};

/**
 * Determines the highest quality resolution available.
 *
 * @remarks
 */
export const MaxResolution = {
  TwoThousandOneHundredAndSixtyp: "2160p",
  OneThousandFourHundredAndFortyp: "1440p",
  OneThousandAndEightyp: "1080p",
  SevenHundredAndTwentyp: "720p",
  FourHundredAndEightyp: "480p",
} as const;
/**
 * Determines the highest quality resolution available.
 *
 * @remarks
 */
export type MaxResolution = ClosedEnum<typeof MaxResolution>;

/**
 * The quality tier applied to the media.
 */
export const MediaQuality = {
  Standard: "standard",
  Pro: "pro",
  Premium: "premium",
} as const;
/**
 * The quality tier applied to the media.
 */
export type MediaQuality = ClosedEnum<typeof MediaQuality>;

/**
 * Generates MP4 video up to 4K ("capped_4k"), m4a audio only ("audioOnly"), or both for offline viewing.
 *
 * @remarks
 */
export const DirectUploadVideoMediaMp4Support = {
  Capped4k: "capped_4k",
  AudioOnly: "audioOnly",
  AudioOnlyCapped4k: "audioOnly,capped_4k",
} as const;
/**
 * Generates MP4 video up to 4K ("capped_4k"), m4a audio only ("audioOnly"), or both for offline viewing.
 *
 * @remarks
 */
export type DirectUploadVideoMediaMp4Support = ClosedEnum<
  typeof DirectUploadVideoMediaMp4Support
>;

export type Summary = {
  /**
   * Enable or disable the summary feature for the media. Set to true to enable summary or false to disable.
   *
   * @remarks
   */
  generate?: boolean | undefined;
  /**
   * Specifies the desired word count for the generated summary.
   *
   * @remarks
   * - The value must be between **30** and **250** words.
   */
  summaryLength?: number | undefined;
};

/**
 * Defines the type of input. Possible values include video, audio, av.
 *
 * @remarks
 */
export const Type = {
  Video: "video",
  Audio: "audio",
  Av: "av",
} as const;
/**
 * Defines the type of input. Possible values include video, audio, av.
 *
 * @remarks
 */
export type Type = ClosedEnum<typeof Type>;

export type DirectUploadVideoMediaModeration = {
  /**
   * Defines the type of input. Possible values include video, audio, av.
   *
   * @remarks
   */
  type?: Type | undefined;
};

/**
 * Specifies the default access policy for domains.
 *
 * @remarks
 * If set to `allow`, all domains are allowed access unless otherwise specified in the `deny` list.
 * If set to `deny`, all domains are denied access unless otherwise specified in the `allow` list.
 */
export const DirectUploadVideoMediaDomainsDefaultPolicy = {
  Allow: "allow",
  Deny: "deny",
} as const;
/**
 * Specifies the default access policy for domains.
 *
 * @remarks
 * If set to `allow`, all domains are allowed access unless otherwise specified in the `deny` list.
 * If set to `deny`, all domains are denied access unless otherwise specified in the `allow` list.
 */
export type DirectUploadVideoMediaDomainsDefaultPolicy = ClosedEnum<
  typeof DirectUploadVideoMediaDomainsDefaultPolicy
>;

export type DirectUploadVideoMediaDomains = {
  /**
   * Specifies the default access policy for domains.
   *
   * @remarks
   * If set to `allow`, all domains are allowed access unless otherwise specified in the `deny` list.
   * If set to `deny`, all domains are denied access unless otherwise specified in the `allow` list.
   */
  defaultPolicy?: DirectUploadVideoMediaDomainsDefaultPolicy | undefined;
  /**
   * A list of domain names or patterns that are explicitly allowed access.
   *
   * @remarks
   * This list is only effective when the `defaultPolicy` is set to `deny`.
   */
  allow?: Array<string> | undefined;
  /**
   * A list of domain names or patterns that are explicitly denied access.
   *
   * @remarks
   * This list is only effective when the `defaultPolicy` is set to `allow`.
   */
  deny?: Array<string> | undefined;
};

/**
 * Specifies the default access policy for user agents (browsers, bots, etc.).
 *
 * @remarks
 * If set to `allow`, all user agents are allowed access unless otherwise specified in the `deny` list.
 * If set to `deny`, all user agents are denied access unless otherwise specified in the `allow` list.
 */
export const DirectUploadVideoMediaUserAgentsDefaultPolicy = {
  Allow: "allow",
  Deny: "deny",
} as const;
/**
 * Specifies the default access policy for user agents (browsers, bots, etc.).
 *
 * @remarks
 * If set to `allow`, all user agents are allowed access unless otherwise specified in the `deny` list.
 * If set to `deny`, all user agents are denied access unless otherwise specified in the `allow` list.
 */
export type DirectUploadVideoMediaUserAgentsDefaultPolicy = ClosedEnum<
  typeof DirectUploadVideoMediaUserAgentsDefaultPolicy
>;

export type DirectUploadVideoMediaUserAgents = {
  /**
   * Specifies the default access policy for user agents (browsers, bots, etc.).
   *
   * @remarks
   * If set to `allow`, all user agents are allowed access unless otherwise specified in the `deny` list.
   * If set to `deny`, all user agents are denied access unless otherwise specified in the `allow` list.
   */
  defaultPolicy?: DirectUploadVideoMediaUserAgentsDefaultPolicy | undefined;
  /**
   * A list of user agents (identified by string names or patterns) that are explicitly allowed access.
   *
   * @remarks
   * This list is only effective when the `defaultPolicy` is set to `deny`.
   */
  allow?: Array<string> | undefined;
  /**
   * A list of user agents (identified by string names or patterns) that are explicitly denied access.
   *
   * @remarks
   * This list is only effective when the `defaultPolicy` is set to `allow`.
   */
  deny?: Array<string> | undefined;
};

export type DirectUploadVideoMediaAccessRestrictions = {
  domains?: DirectUploadVideoMediaDomains | undefined;
  userAgents?: DirectUploadVideoMediaUserAgents | undefined;
};

/**
 * Configuration settings for uploading and processing media on the FastPix platform.
 *
 * @remarks
 * These settings define how the uploaded video is handled, including access control, resolution, DRM, and optional metadata.
 * For a complete explanation of how media uploads and processing work, refer to the
 * <a href="https://docs.fastpix.io/docs/video-on-demand-overview" target="_blank">FastPix Video on Demand Overview</a>.
 */
export type PushMediaSettings = {
  /**
   * Determines if access to the streamed content is kept private, drm or available to all.
   */
  accessPolicy?: DirectUploadVideoMediaAccessPolicy | undefined;
  /**
   * Start time indicates where encoding must begin within the video file, in seconds.
   */
  startTime?: number | undefined;
  /**
   * End time indicates where encoding must end within the video file, in seconds.
   */
  endTime?: number | undefined;
  /**
   * Add one input object at a time. For example, first add a **WatermarkInput** object.   If you also need a audio, click **Add item** again and select **AudioInput**.   Repeat this process for **SubtitleInput** as needed.
   *
   * @remarks
   */
  inputs?:
    | Array<
      | models.SubtitleInput
      | models.WatermarkInput
      | models.AudioInput
      | models.VideoInput
    >
    | undefined;
  /**
   * "Tag a video in "key" : "value" pairs for searchable metadata. Maximum 10 entries, 255 characters each."
   *
   * @remarks
   */
  metadata?: { [k: string]: string } | undefined;
  /**
   * UUID of the DRM configuration to be used.
   */
  drmConfigurationId?: string | undefined;
  /**
   * Title of the media file.
   */
  title?: string | undefined;
  /**
   * The unique identifier of the user who created this media.
   */
  creatorId?: string | undefined;
  /**
   * Generates subtitle files for audio/video files.
   *
   * @remarks
   */
  subtitles?: Subtitles | undefined;
  /**
   * Enhance the quality and volume of the audio track. This is available for pre-recorded content only.
   *
   * @remarks
   */
  optimizeAudio?: boolean | undefined;
  /**
   * Determines the highest quality resolution available.
   *
   * @remarks
   */
  maxResolution?: MaxResolution | undefined;
  /**
   * The quality tier applied to the media.
   */
  mediaQuality?: MediaQuality | undefined;
  /**
   * The sourceAccess parameter determines whether the original media file is accessible. Set to true to enable access or false to restrict it
   */
  sourceAccess?: boolean | undefined;
  /**
   * Generates MP4 video up to 4K ("capped_4k"), m4a audio only ("audioOnly"), or both for offline viewing.
   *
   * @remarks
   */
  mp4Support?: DirectUploadVideoMediaMp4Support | undefined;
  summary?: Summary | undefined;
  /**
   * Enable or disable the chapters feature for the media. Set to `true` to enable chapters or `false` to disable.
   *
   * @remarks
   */
  chapters?: boolean | undefined;
  /**
   * Enable or disable named entity extraction. Set to `true` to enable or `false` to disable.
   *
   * @remarks
   */
  namedEntities?: boolean | undefined;
  moderation?: DirectUploadVideoMediaModeration | undefined;
  accessRestrictions?: DirectUploadVideoMediaAccessRestrictions | undefined;
};

/**
 * Request body for direct upload
 */
export type DirectUploadVideoMediaRequest = {
  /**
   * Upload media directly from a device using the URL name or enter "*" to allow all.
   */
  corsOrigin?: string | undefined;
  /**
   * Configuration settings for uploading and processing media on the FastPix platform.
   *
   * @remarks
   * These settings define how the uploaded video is handled, including access control, resolution, DRM, and optional metadata.
   * For a complete explanation of how media uploads and processing work, refer to the
   * <a href="https://docs.fastpix.io/docs/video-on-demand-overview" target="_blank">FastPix Video on Demand Overview</a>.
   */
  pushMediaSettings?: PushMediaSettings | undefined;
};

/**
 * Direct upload created successfully
 */
export type DirectUploadVideoMediaResponseBody = {
  /**
   * Shows the request status. Returns true for success and false for failure.
   */
  success?: boolean | undefined;
  /**
   * Displays the result of the request.
   */
  data?: models.DirectUpload | undefined;
};

export type DirectUploadVideoMediaResponse =
  | DirectUploadVideoMediaResponseBody
  | models.DefaultError;

/** @internal */
export const DirectUploadVideoMediaAccessPolicy$outboundSchema: z.ZodMiniEnum<
  typeof DirectUploadVideoMediaAccessPolicy
> = z.enum(DirectUploadVideoMediaAccessPolicy);

/** @internal */
export type Input$Outbound =
  | models.SubtitleInput$Outbound
  | models.WatermarkInput$Outbound
  | models.AudioInput$Outbound
  | models.VideoInput$Outbound;

/** @internal */
export const Input$outboundSchema: z.ZodMiniType<Input$Outbound, Input> =
  smartUnion([
    models.SubtitleInput$outboundSchema,
    models.WatermarkInput$outboundSchema,
    models.AudioInput$outboundSchema,
    models.VideoInput$outboundSchema,
  ]);

export function inputToJSON(input: Input): string {
  return JSON.stringify(Input$outboundSchema.parse(input));
}

/** @internal */
export const LanguageCode$outboundSchema: z.ZodMiniEnum<typeof LanguageCode> = z
  .enum(LanguageCode);

/** @internal */
export type Subtitles$Outbound = {
  languageName?: string | undefined;
  metadata?: { [k: string]: string } | undefined;
  languageCode?: string | undefined;
};

/** @internal */
export const Subtitles$outboundSchema: z.ZodMiniType<
  Subtitles$Outbound,
  Subtitles
> = z.object({
  languageName: z.optional(z.string()),
  metadata: z.optional(z.record(z.string(), z.string())),
  languageCode: z.optional(LanguageCode$outboundSchema),
});

export function subtitlesToJSON(subtitles: Subtitles): string {
  return JSON.stringify(Subtitles$outboundSchema.parse(subtitles));
}

/** @internal */
export const MaxResolution$outboundSchema: z.ZodMiniEnum<typeof MaxResolution> =
  z.enum(MaxResolution);

/** @internal */
export const MediaQuality$outboundSchema: z.ZodMiniEnum<typeof MediaQuality> = z
  .enum(MediaQuality);

/** @internal */
export const DirectUploadVideoMediaMp4Support$outboundSchema: z.ZodMiniEnum<
  typeof DirectUploadVideoMediaMp4Support
> = z.enum(DirectUploadVideoMediaMp4Support);

/** @internal */
export type Summary$Outbound = {
  generate?: boolean | undefined;
  summaryLength?: number | undefined;
};

/** @internal */
export const Summary$outboundSchema: z.ZodMiniType<Summary$Outbound, Summary> =
  z.object({
    generate: z.optional(z.boolean()),
    summaryLength: z.optional(z.int()),
  });

export function summaryToJSON(summary: Summary): string {
  return JSON.stringify(Summary$outboundSchema.parse(summary));
}

/** @internal */
export const Type$outboundSchema: z.ZodMiniEnum<typeof Type> = z.enum(Type);

/** @internal */
export type DirectUploadVideoMediaModeration$Outbound = {
  type?: string | undefined;
};

/** @internal */
export const DirectUploadVideoMediaModeration$outboundSchema: z.ZodMiniType<
  DirectUploadVideoMediaModeration$Outbound,
  DirectUploadVideoMediaModeration
> = z.object({
  type: z.optional(Type$outboundSchema),
});

export function directUploadVideoMediaModerationToJSON(
  directUploadVideoMediaModeration: DirectUploadVideoMediaModeration,
): string {
  return JSON.stringify(
    DirectUploadVideoMediaModeration$outboundSchema.parse(
      directUploadVideoMediaModeration,
    ),
  );
}

/** @internal */
export const DirectUploadVideoMediaDomainsDefaultPolicy$outboundSchema:
  z.ZodMiniEnum<typeof DirectUploadVideoMediaDomainsDefaultPolicy> = z.enum(
    DirectUploadVideoMediaDomainsDefaultPolicy,
  );

/** @internal */
export type DirectUploadVideoMediaDomains$Outbound = {
  defaultPolicy?: string | undefined;
  allow?: Array<string> | undefined;
  deny?: Array<string> | undefined;
};

/** @internal */
export const DirectUploadVideoMediaDomains$outboundSchema: z.ZodMiniType<
  DirectUploadVideoMediaDomains$Outbound,
  DirectUploadVideoMediaDomains
> = z.object({
  defaultPolicy: z.optional(
    DirectUploadVideoMediaDomainsDefaultPolicy$outboundSchema,
  ),
  allow: z.optional(z.array(z.string())),
  deny: z.optional(z.array(z.string())),
});

export function directUploadVideoMediaDomainsToJSON(
  directUploadVideoMediaDomains: DirectUploadVideoMediaDomains,
): string {
  return JSON.stringify(
    DirectUploadVideoMediaDomains$outboundSchema.parse(
      directUploadVideoMediaDomains,
    ),
  );
}

/** @internal */
export const DirectUploadVideoMediaUserAgentsDefaultPolicy$outboundSchema:
  z.ZodMiniEnum<typeof DirectUploadVideoMediaUserAgentsDefaultPolicy> = z.enum(
    DirectUploadVideoMediaUserAgentsDefaultPolicy,
  );

/** @internal */
export type DirectUploadVideoMediaUserAgents$Outbound = {
  defaultPolicy?: string | undefined;
  allow?: Array<string> | undefined;
  deny?: Array<string> | undefined;
};

/** @internal */
export const DirectUploadVideoMediaUserAgents$outboundSchema: z.ZodMiniType<
  DirectUploadVideoMediaUserAgents$Outbound,
  DirectUploadVideoMediaUserAgents
> = z.object({
  defaultPolicy: z.optional(
    DirectUploadVideoMediaUserAgentsDefaultPolicy$outboundSchema,
  ),
  allow: z.optional(z.array(z.string())),
  deny: z.optional(z.array(z.string())),
});

export function directUploadVideoMediaUserAgentsToJSON(
  directUploadVideoMediaUserAgents: DirectUploadVideoMediaUserAgents,
): string {
  return JSON.stringify(
    DirectUploadVideoMediaUserAgents$outboundSchema.parse(
      directUploadVideoMediaUserAgents,
    ),
  );
}

/** @internal */
export type DirectUploadVideoMediaAccessRestrictions$Outbound = {
  domains?: DirectUploadVideoMediaDomains$Outbound | undefined;
  userAgents?: DirectUploadVideoMediaUserAgents$Outbound | undefined;
};

/** @internal */
export const DirectUploadVideoMediaAccessRestrictions$outboundSchema:
  z.ZodMiniType<
    DirectUploadVideoMediaAccessRestrictions$Outbound,
    DirectUploadVideoMediaAccessRestrictions
  > = z.object({
    domains: z.optional(
      z.lazy(() => DirectUploadVideoMediaDomains$outboundSchema),
    ),
    userAgents: z.optional(
      z.lazy(() => DirectUploadVideoMediaUserAgents$outboundSchema),
    ),
  });

export function directUploadVideoMediaAccessRestrictionsToJSON(
  directUploadVideoMediaAccessRestrictions:
    DirectUploadVideoMediaAccessRestrictions,
): string {
  return JSON.stringify(
    DirectUploadVideoMediaAccessRestrictions$outboundSchema.parse(
      directUploadVideoMediaAccessRestrictions,
    ),
  );
}

/** @internal */
export type PushMediaSettings$Outbound = {
  accessPolicy: string;
  startTime?: number | undefined;
  endTime?: number | undefined;
  inputs?:
    | Array<
      | models.SubtitleInput$Outbound
      | models.WatermarkInput$Outbound
      | models.AudioInput$Outbound
      | models.VideoInput$Outbound
    >
    | undefined;
  metadata?: { [k: string]: string } | undefined;
  drmConfigurationId?: string | undefined;
  title?: string | undefined;
  creatorId?: string | undefined;
  subtitles?: Subtitles$Outbound | undefined;
  optimizeAudio?: boolean | undefined;
  maxResolution: string;
  mediaQuality: string;
  sourceAccess?: boolean | undefined;
  mp4Support?: string | undefined;
  summary?: Summary$Outbound | undefined;
  chapters?: boolean | undefined;
  namedEntities?: boolean | undefined;
  moderation?: DirectUploadVideoMediaModeration$Outbound | undefined;
  accessRestrictions?:
    | DirectUploadVideoMediaAccessRestrictions$Outbound
    | undefined;
};

/** @internal */
export const PushMediaSettings$outboundSchema: z.ZodMiniType<
  PushMediaSettings$Outbound,
  PushMediaSettings
> = z.object({
  accessPolicy: z._default(
    DirectUploadVideoMediaAccessPolicy$outboundSchema,
    "public",
  ),
  startTime: z.optional(z.number()),
  endTime: z.optional(z.number()),
  inputs: z.optional(
    z.array(
      smartUnion([
        models.SubtitleInput$outboundSchema,
        models.WatermarkInput$outboundSchema,
        models.AudioInput$outboundSchema,
        models.VideoInput$outboundSchema,
      ]),
    ),
  ),
  metadata: z.optional(z.record(z.string(), z.string())),
  drmConfigurationId: z.optional(z.string()),
  title: z.optional(z.string()),
  creatorId: z.optional(z.string()),
  subtitles: z.optional(z.lazy(() => Subtitles$outboundSchema)),
  optimizeAudio: z.optional(z.boolean()),
  maxResolution: z._default(MaxResolution$outboundSchema, "1080p"),
  mediaQuality: z._default(MediaQuality$outboundSchema, "standard"),
  sourceAccess: z.optional(z.boolean()),
  mp4Support: z.optional(DirectUploadVideoMediaMp4Support$outboundSchema),
  summary: z.optional(z.lazy(() => Summary$outboundSchema)),
  chapters: z.optional(z.boolean()),
  namedEntities: z.optional(z.boolean()),
  moderation: z.optional(
    z.lazy(() => DirectUploadVideoMediaModeration$outboundSchema),
  ),
  accessRestrictions: z.optional(
    z.lazy(() => DirectUploadVideoMediaAccessRestrictions$outboundSchema),
  ),
});

export function pushMediaSettingsToJSON(
  pushMediaSettings: PushMediaSettings,
): string {
  return JSON.stringify(
    PushMediaSettings$outboundSchema.parse(pushMediaSettings),
  );
}

/** @internal */
export type DirectUploadVideoMediaRequest$Outbound = {
  corsOrigin: string;
  pushMediaSettings?: PushMediaSettings$Outbound | undefined;
};

/** @internal */
export const DirectUploadVideoMediaRequest$outboundSchema: z.ZodMiniType<
  DirectUploadVideoMediaRequest$Outbound,
  DirectUploadVideoMediaRequest
> = z.object({
  corsOrigin: z._default(z.string(), "*"),
  pushMediaSettings: z.optional(z.lazy(() => PushMediaSettings$outboundSchema)),
});

export function directUploadVideoMediaRequestToJSON(
  directUploadVideoMediaRequest: DirectUploadVideoMediaRequest,
): string {
  return JSON.stringify(
    DirectUploadVideoMediaRequest$outboundSchema.parse(
      directUploadVideoMediaRequest,
    ),
  );
}

/** @internal */
export const DirectUploadVideoMediaResponseBody$inboundSchema: z.ZodMiniType<
  DirectUploadVideoMediaResponseBody,
  unknown
> = z.object({
  success: types.optional(types.boolean()),
  data: types.optional(models.DirectUpload$inboundSchema),
});

export function directUploadVideoMediaResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<DirectUploadVideoMediaResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      DirectUploadVideoMediaResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DirectUploadVideoMediaResponseBody' from JSON`,
  );
}

/** @internal */
export const DirectUploadVideoMediaResponse$inboundSchema: z.ZodMiniType<
  DirectUploadVideoMediaResponse,
  unknown
> = smartUnion([
  z.lazy(() => DirectUploadVideoMediaResponseBody$inboundSchema),
  models.DefaultError$inboundSchema,
]);

export function directUploadVideoMediaResponseFromJSON(
  jsonString: string,
): SafeParseResult<DirectUploadVideoMediaResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DirectUploadVideoMediaResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DirectUploadVideoMediaResponse' from JSON`,
  );
}
