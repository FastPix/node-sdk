/*
* This file is auto-generated.
 * Do not edit this file manually.
 * Your changes will be overwritten during the next generation.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { smartUnion } from "../../types/smartUnion.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import * as models from "../index.js";

/**
 * This parameter specifies the time span between which the video views list must be retrieved by. You can provide either from and to unix epoch timestamps or time duration. The scope of duration is between 60 minutes to 30 days.
 *
 * @remarks
 *
 * **Accepted formats are:**
 *
 * array of epoch timestamps for example
 * `timespan[]=1498867200&timespan[]=1498953600`
 *
 * duration string for example
 * `timespan[]=24:hours` or `timespan[]=7:days`
 */
export const ListErrorsTimespan = {
  Sixtyminutes: "60:minutes",
  Sixhours: "6:hours",
  TwentyFourhours: "24:hours",
  Threedays: "3:days",
  Sevendays: "7:days",
  Thirtydays: "30:days",
} as const;
/**
 * This parameter specifies the time span between which the video views list must be retrieved by. You can provide either from and to unix epoch timestamps or time duration. The scope of duration is between 60 minutes to 30 days.
 *
 * @remarks
 *
 * **Accepted formats are:**
 *
 * array of epoch timestamps for example
 * `timespan[]=1498867200&timespan[]=1498953600`
 *
 * duration string for example
 * `timespan[]=24:hours` or `timespan[]=7:days`
 */
export type ListErrorsTimespan = ClosedEnum<typeof ListErrorsTimespan>;

export type ListErrorsRequest = {
  /**
   * This parameter specifies the time span between which the video views list must be retrieved by. You can provide either from and to unix epoch timestamps or time duration. The scope of duration is between 60 minutes to 30 days.
   *
   * @remarks
   *
   * **Accepted formats are:**
   *
   * array of epoch timestamps for example
   * `timespan[]=1498867200&timespan[]=1498953600`
   *
   * duration string for example
   * `timespan[]=24:hours` or `timespan[]=7:days`
   */
  timespan?: ListErrorsTimespan | undefined;
  /**
   * Pass the dimensions and their corresponding values you want to filter the views by. For excluding the values in the filter we can pass "!" before the filter value. The list of filters can be obtained from list of dimensions endpoint.
   *
   * @remarks
   * Example Values : [ browser_name:Chrome , os_name:macOS , !device_name:Galaxy ]
   */
  filterby?: string | undefined;
  /**
   * Pass the limit to display only the rows specified by the value for top errors.
   *
   * @remarks
   */
  limit?: number | undefined;
};

/**
 * Displays the result of the request.
 */
export type ListErrorsData = {
  /**
   * The endpoint retrieves a comprehensive list of errors that have occurred by providing detailed information about each error instance.
   */
  errors?: Array<models.ErrorDetails> | undefined;
  /**
   * Retrieves a list of errors that have occurred most frequently in the system, ranked by their count of occurrences.
   */
  topErrors?: Array<models.TopErrorDetails> | undefined;
};

/**
 * Get filter/ dimension value details by dimension name.
 */
export type ListErrorsResponseBody = {
  /**
   * Shows the request status. Returns true for success and false for failure.
   */
  success?: boolean | undefined;
  /**
   * Displays the result of the request.
   */
  data?: ListErrorsData | undefined;
  /**
   * The timespan from and to details displayed in the form of unix epoch timestamps.
   *
   * @remarks
   */
  timespan?: Array<number> | undefined;
};

export type ListErrorsResponse = ListErrorsResponseBody | models.DefaultError;

/** @internal */
export const ListErrorsTimespan$outboundSchema: z.ZodMiniEnum<
  typeof ListErrorsTimespan
> = z.enum(ListErrorsTimespan);

/** @internal */
export type ListErrorsRequest$Outbound = {
  "timespan[]"?: string | undefined;
  "filterby[]"?: string | undefined;
  limit: number;
};

/** @internal */
export const ListErrorsRequest$outboundSchema: z.ZodMiniType<
  ListErrorsRequest$Outbound,
  ListErrorsRequest
> = z.pipe(
  z.object({
    timespan: z.optional(ListErrorsTimespan$outboundSchema),
    filterby: z.optional(z.string()),
    limit: z._default(z.int(), 1),
  }),
  z.transform((v) => {
    return remap$(v, {
      timespan: "timespan[]",
      filterby: "filterby[]",
    });
  }),
);

export function listErrorsRequestToJSON(
  listErrorsRequest: ListErrorsRequest,
): string {
  return JSON.stringify(
    ListErrorsRequest$outboundSchema.parse(listErrorsRequest),
  );
}

/** @internal */
export const ListErrorsData$inboundSchema: z.ZodMiniType<
  ListErrorsData,
  unknown
> = z.object({
  errors: types.optional(z.array(models.ErrorDetails$inboundSchema)),
  topErrors: types.optional(z.array(models.TopErrorDetails$inboundSchema)),
});

export function listErrorsDataFromJSON(
  jsonString: string,
): SafeParseResult<ListErrorsData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListErrorsData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListErrorsData' from JSON`,
  );
}

/** @internal */
export const ListErrorsResponseBody$inboundSchema: z.ZodMiniType<
  ListErrorsResponseBody,
  unknown
> = z.object({
  success: types.optional(types.boolean()),
  data: types.optional(z.lazy(() => ListErrorsData$inboundSchema)),
  timespan: types.optional(z.array(types.number())),
});

export function listErrorsResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<ListErrorsResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListErrorsResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListErrorsResponseBody' from JSON`,
  );
}

/** @internal */
export const ListErrorsResponse$inboundSchema: z.ZodMiniType<
  ListErrorsResponse,
  unknown
> = smartUnion([
  z.lazy(() => ListErrorsResponseBody$inboundSchema),
  models.DefaultError$inboundSchema,
]);

export function listErrorsResponseFromJSON(
  jsonString: string,
): SafeParseResult<ListErrorsResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListErrorsResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListErrorsResponse' from JSON`,
  );
}
