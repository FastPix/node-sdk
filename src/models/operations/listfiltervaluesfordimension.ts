/*
* This file is auto-generated.
 * Do not edit this file manually.
 * Your changes will be overwritten during the next generation.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { smartUnion } from "../../types/smartUnion.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import * as models from "../index.js";

/**
 * Pass Dimensions Id
 *
 * @remarks
 */
export const DimensionsId = {
  BrowserName: "browser_name",
  BrowserVersion: "browser_version",
  OsName: "os_name",
  OsVersion: "os_version",
  DeviceName: "device_name",
  DeviceModel: "device_model",
  DeviceType: "device_type",
  DeviceManufacturer: "device_manufacturer",
  PlayerRemotePlayed: "player_remote_played",
  PlayerName: "player_name",
  PlayerVersion: "player_version",
  PlayerSoftwareName: "player_software_name",
  PlayerSoftwareVersion: "player_software_version",
  PlayerResolution: "player_resolution",
  FpSDK: "fp_sdk",
  FpSDKVersion: "fp_sdk_version",
  PlayerAutoplayOn: "player_autoplay_on",
  PlayerPreloadOn: "player_preload_on",
  VideoTitle: "video_title",
  VideoId: "video_id",
  VideoSeries: "video_series",
  FpPlaybackId: "fp_playback_id",
  FpLiveStreamId: "fp_live_stream_id",
  MediaId: "media_id",
  VideoSourceStreamType: "video_source_stream_type",
  VideoSourceType: "video_source_type",
  VideoEncodingVariant: "video_encoding_variant",
  ExperimentName: "experiment_name",
  SubPropertyId: "sub_property_id",
  DrmType: "drm_type",
  AsnName: "asn_name",
  Cdn: "cdn",
  VideoSourceHostname: "video_source_hostname",
  ConnectionType: "connection_type",
  ViewSessionId: "view_session_id",
  Continent: "continent",
  Country: "country",
  Region: "region",
  ViewerId: "viewer_id",
  ErrorCode: "error_code",
  ExitBeforeVideoStart: "exit_before_video_start",
  ViewHasAd: "view_has_ad",
  VideoStartupFailed: "video_startup_failed",
  VideoContentType: "video_content_type",
  PageContext: "page_context",
  PlaybackFailed: "playback_failed",
  Custom1: "custom_1",
  Custom2: "custom_2",
  Custom3: "custom_3",
  Custom4: "custom_4",
  Custom5: "custom_5",
  Custom6: "custom_6",
  Custom7: "custom_7",
  Custom8: "custom_8",
  Custom9: "custom_9",
  Custom10: "custom_10",
} as const;
/**
 * Pass Dimensions Id
 *
 * @remarks
 */
export type DimensionsId = ClosedEnum<typeof DimensionsId>;

/**
 * This parameter specifies the time span between which the video views list must be retrieved by. You can provide either from and to unix epoch timestamps or time duration. The scope of duration is between 60 minutes to 30 days.
 *
 * @remarks
 *
 * **Accepted formats are:**
 *
 * array of epoch timestamps for example
 * `timespan[]=1498867200&timespan[]=1498953600`
 *
 * duration string for example
 * `timespan[]=24:hours` or `timespan[]=7:days`
 */
export const ListFilterValuesForDimensionTimespan = {
  Sixtyminutes: "60:minutes",
  Sixhours: "6:hours",
  TwentyFourhours: "24:hours",
  Threedays: "3:days",
  Sevendays: "7:days",
  Thirtydays: "30:days",
} as const;
/**
 * This parameter specifies the time span between which the video views list must be retrieved by. You can provide either from and to unix epoch timestamps or time duration. The scope of duration is between 60 minutes to 30 days.
 *
 * @remarks
 *
 * **Accepted formats are:**
 *
 * array of epoch timestamps for example
 * `timespan[]=1498867200&timespan[]=1498953600`
 *
 * duration string for example
 * `timespan[]=24:hours` or `timespan[]=7:days`
 */
export type ListFilterValuesForDimensionTimespan = ClosedEnum<
  typeof ListFilterValuesForDimensionTimespan
>;

export type ListFilterValuesForDimensionRequest = {
  /**
   * Pass Dimensions Id
   *
   * @remarks
   */
  dimensionsId: DimensionsId;
  /**
   * This parameter specifies the time span between which the video views list must be retrieved by. You can provide either from and to unix epoch timestamps or time duration. The scope of duration is between 60 minutes to 30 days.
   *
   * @remarks
   *
   * **Accepted formats are:**
   *
   * array of epoch timestamps for example
   * `timespan[]=1498867200&timespan[]=1498953600`
   *
   * duration string for example
   * `timespan[]=24:hours` or `timespan[]=7:days`
   */
  timespan?: ListFilterValuesForDimensionTimespan | undefined;
  /**
   * Pass the dimensions and their corresponding values you want to filter the views by. For excluding the values in the filter we can pass "!" before the filter value. The list of filters can be obtained from list of dimensions endpoint.
   *
   * @remarks
   * Example Values : [ browser_name:Chrome , os_name:macOS , !device_name:Galaxy ]
   */
  filterby?: string | undefined;
};

/**
 * Get filter / dimension value details by dimension name.
 */
export type ListFilterValuesForDimensionResponseBody = {
  /**
   * Shows the request status. Returns true for success and false for failure.
   */
  success?: boolean | undefined;
  /**
   * filter values associated with a specific dimension
   */
  data?: Array<models.BrowserNameDimensiondetails> | undefined;
  /**
   * The timespan from and to details displayed in the form of unix epoch timestamps.
   *
   * @remarks
   */
  timespan?: Array<number> | undefined;
};

export type ListFilterValuesForDimensionResponse =
  | ListFilterValuesForDimensionResponseBody
  | models.DefaultError;

/** @internal */
export const DimensionsId$outboundSchema: z.ZodMiniEnum<typeof DimensionsId> = z
  .enum(DimensionsId);

/** @internal */
export const ListFilterValuesForDimensionTimespan$outboundSchema: z.ZodMiniEnum<
  typeof ListFilterValuesForDimensionTimespan
> = z.enum(ListFilterValuesForDimensionTimespan);

/** @internal */
export type ListFilterValuesForDimensionRequest$Outbound = {
  dimensionsId: string;
  "timespan[]"?: string | undefined;
  "filterby[]"?: string | undefined;
};

/** @internal */
export const ListFilterValuesForDimensionRequest$outboundSchema: z.ZodMiniType<
  ListFilterValuesForDimensionRequest$Outbound,
  ListFilterValuesForDimensionRequest
> = z.pipe(
  z.object({
    dimensionsId: DimensionsId$outboundSchema,
    timespan: z.optional(ListFilterValuesForDimensionTimespan$outboundSchema),
    filterby: z.optional(z.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      timespan: "timespan[]",
      filterby: "filterby[]",
    });
  }),
);

export function listFilterValuesForDimensionRequestToJSON(
  listFilterValuesForDimensionRequest: ListFilterValuesForDimensionRequest,
): string {
  return JSON.stringify(
    ListFilterValuesForDimensionRequest$outboundSchema.parse(
      listFilterValuesForDimensionRequest,
    ),
  );
}

/** @internal */
export const ListFilterValuesForDimensionResponseBody$inboundSchema:
  z.ZodMiniType<ListFilterValuesForDimensionResponseBody, unknown> = z.object({
    success: types.optional(types.boolean()),
    data: types.optional(
      z.array(models.BrowserNameDimensiondetails$inboundSchema),
    ),
    timespan: types.optional(z.array(types.number())),
  });

export function listFilterValuesForDimensionResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  ListFilterValuesForDimensionResponseBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListFilterValuesForDimensionResponseBody$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListFilterValuesForDimensionResponseBody' from JSON`,
  );
}

/** @internal */
export const ListFilterValuesForDimensionResponse$inboundSchema: z.ZodMiniType<
  ListFilterValuesForDimensionResponse,
  unknown
> = smartUnion([
  z.lazy(() => ListFilterValuesForDimensionResponseBody$inboundSchema),
  models.DefaultError$inboundSchema,
]);

export function listFilterValuesForDimensionResponseFromJSON(
  jsonString: string,
): SafeParseResult<ListFilterValuesForDimensionResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListFilterValuesForDimensionResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListFilterValuesForDimensionResponse' from JSON`,
  );
}
