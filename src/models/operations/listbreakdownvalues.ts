/*
* This file is auto-generated.
 * Do not edit this file manually.
 * Your changes will be overwritten during the next generation.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { smartUnion } from "../../types/smartUnion.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import * as models from "../index.js";

/**
 * Pass metric Id
 *
 * @remarks
 */
export const ListBreakdownValuesMetricId = {
  Views: "views",
  UniqueViewers: "unique_viewers",
  PlayingTime: "playing_time",
  QualityOfExperienceScore: "quality_of_experience_score",
  PlaybackScore: "playback_score",
  PlaybackFailurePercentage: "playback_failure_percentage",
  ExitBeforeVideoStart: "exit_before_video_start",
  VideoStartupFailurePercentage: "video_startup_failure_percentage",
  StartupScore: "startup_score",
  VideoStartupTime: "video_startup_time",
  PlayerStartupTime: "player_startup_time",
  PageLoadTime: "page_load_time",
  TotalStartupTime: "total_startup_time",
  LiveStreamLatency: "live_stream_latency",
  AverageBitrate: "average_bitrate",
  BufferCount: "buffer_count",
  RenderQualityScore: "render_quality_score",
  AvgUpscaling: "avg_upscaling",
  AvgDownscaling: "avg_downscaling",
  MaxUpscaling: "max_upscaling",
  MaxDownscaling: "max_downscaling",
  JumpLatency: "jump_latency",
  StabilityScore: "stability_score",
  BufferRatio: "buffer_ratio",
  BufferFrequency: "buffer_frequency",
  BufferFill: "buffer_fill",
} as const;
/**
 * Pass metric Id
 *
 * @remarks
 */
export type ListBreakdownValuesMetricId = ClosedEnum<
  typeof ListBreakdownValuesMetricId
>;

/**
 * This parameter specifies the time span between which the video views list must be retrieved by. You can provide either from and to unix epoch timestamps or time duration. The scope of duration is between 60 minutes to 30 days.
 *
 * @remarks
 *
 * **Accepted formats are:**
 *
 * array of epoch timestamps for example
 * `timespan[]=1498867200&timespan[]=1498953600`
 *
 * duration string for example
 * `timespan[]=24:hours` or `timespan[]=7:days`
 */
export const ListBreakdownValuesTimespan = {
  Sixtyminutes: "60:minutes",
  Sixhours: "6:hours",
  TwentyFourhours: "24:hours",
  Threedays: "3:days",
  Sevendays: "7:days",
  Thirtydays: "30:days",
} as const;
/**
 * This parameter specifies the time span between which the video views list must be retrieved by. You can provide either from and to unix epoch timestamps or time duration. The scope of duration is between 60 minutes to 30 days.
 *
 * @remarks
 *
 * **Accepted formats are:**
 *
 * array of epoch timestamps for example
 * `timespan[]=1498867200&timespan[]=1498953600`
 *
 * duration string for example
 * `timespan[]=24:hours` or `timespan[]=7:days`
 */
export type ListBreakdownValuesTimespan = ClosedEnum<
  typeof ListBreakdownValuesTimespan
>;

/**
 * The order direction to sort the metrics list by.
 *
 * @remarks
 */
export const ListBreakdownValuesSortOrder = {
  Asc: "asc",
  Desc: "desc",
} as const;
/**
 * The order direction to sort the metrics list by.
 *
 * @remarks
 */
export type ListBreakdownValuesSortOrder = ClosedEnum<
  typeof ListBreakdownValuesSortOrder
>;

export type ListBreakdownValuesRequest = {
  /**
   * Pass metric Id
   *
   * @remarks
   */
  metricId: ListBreakdownValuesMetricId;
  /**
   * This parameter specifies the time span between which the video views list must be retrieved by. You can provide either from and to unix epoch timestamps or time duration. The scope of duration is between 60 minutes to 30 days.
   *
   * @remarks
   *
   * **Accepted formats are:**
   *
   * array of epoch timestamps for example
   * `timespan[]=1498867200&timespan[]=1498953600`
   *
   * duration string for example
   * `timespan[]=24:hours` or `timespan[]=7:days`
   */
  timespan?: ListBreakdownValuesTimespan | undefined;
  /**
   * Pass the dimensions and their corresponding values you want to filter the views by. For excluding the values in the filter we can pass "!" before the filter value. The list of filters can be obtained from list of dimensions endpoint.
   *
   * @remarks
   * Example Values : [ browser_name:Chrome , os_name:macOS , !device_name:Galaxy ]
   */
  filterby?: string | undefined;
  /**
   * Pass the limit to display only the rows specified by the value.
   *
   * @remarks
   */
  limit?: number | undefined;
  /**
   * Pass the offset value to indicate the page number.
   *
   * @remarks
   */
  offset?: number | undefined;
  /**
   * Pass this value to group the metrics list by.
   *
   * @remarks
   * Possible Values : ["browser_name", "browser_version", "os_name","os_version" , "device_name", "device_model", "device_type", "device_manufacturer", "player_remote_played",player_name", "player_version", "player_software_name", "player_software_version", "player_resolution", "fp_sdk","fp_sdk_version", "player_autoplay_on", "player_preload_on","video_title",  "video_id", "video_series" ,  "fp_playback_id","fp_live_stream_id", "media_id","video_source_stream_type", "video_source_type", "video_encoding_variant", "experiment_name", "sub_property_id", "drm_type","asn_name", "cdn", "video_source_hostname", "connection_type", "view_session_id","continent","country", "region","viewer_id", "error_code", "exit_before_video_start", "view_has_ad", "video_startup_failed" , "page_context", "playback_failed".]
   */
  groupBy?: string | undefined;
  /**
   * Pass this value to order the metrics list by.
   *
   * @remarks
   */
  orderBy?: string | undefined;
  /**
   * The order direction to sort the metrics list by.
   *
   * @remarks
   */
  sortOrder?: ListBreakdownValuesSortOrder | undefined;
  /**
   * The measurement for the given metrics.
   *
   * @remarks
   * Possible Values : [95th, median, avg, count or sum]
   */
  measurement?: string | undefined;
};

/**
 * Get filter/ dimension value details by dimension name.
 */
export type ListBreakdownValuesResponseBody = {
  /**
   * Shows the request status. Returns true for success and false for failure.
   */
  success?: boolean | undefined;
  /**
   * Retrieves breakdown values for a specified metric and timespan
   */
  metadata?: models.MetricsmetadataDetails | undefined;
  /**
   * Retrieves breakdown values for a specified metric and timespan
   */
  data?: Array<models.MetricsBreakdownDetails> | undefined;
  /**
   * Pagination organizes content into pages for better readability and navigation.
   */
  pagination?: models.DataPagination | undefined;
  /**
   * The timespan from and to details displayed in the form of unix epoch timestamps.
   *
   * @remarks
   */
  timespan?: Array<number> | undefined;
};

export type ListBreakdownValuesResponse =
  | ListBreakdownValuesResponseBody
  | models.DefaultError;

/** @internal */
export const ListBreakdownValuesMetricId$outboundSchema: z.ZodMiniEnum<
  typeof ListBreakdownValuesMetricId
> = z.enum(ListBreakdownValuesMetricId);

/** @internal */
export const ListBreakdownValuesTimespan$outboundSchema: z.ZodMiniEnum<
  typeof ListBreakdownValuesTimespan
> = z.enum(ListBreakdownValuesTimespan);

/** @internal */
export const ListBreakdownValuesSortOrder$outboundSchema: z.ZodMiniEnum<
  typeof ListBreakdownValuesSortOrder
> = z.enum(ListBreakdownValuesSortOrder);

/** @internal */
export type ListBreakdownValuesRequest$Outbound = {
  metricId: string;
  "timespan[]"?: string | undefined;
  "filterby[]"?: string | undefined;
  limit: number;
  offset: number;
  groupBy?: string | undefined;
  orderBy: string;
  sortOrder: string;
  measurement: string;
};

/** @internal */
export const ListBreakdownValuesRequest$outboundSchema: z.ZodMiniType<
  ListBreakdownValuesRequest$Outbound,
  ListBreakdownValuesRequest
> = z.pipe(
  z.object({
    metricId: ListBreakdownValuesMetricId$outboundSchema,
    timespan: z.optional(ListBreakdownValuesTimespan$outboundSchema),
    filterby: z.optional(z.string()),
    limit: z._default(z.int(), 10),
    offset: z._default(z.int(), 1),
    groupBy: z.optional(z.string()),
    orderBy: z._default(z.string(), "views"),
    sortOrder: z._default(ListBreakdownValuesSortOrder$outboundSchema, "asc"),
    measurement: z._default(z.string(), "avg"),
  }),
  z.transform((v) => {
    return remap$(v, {
      timespan: "timespan[]",
      filterby: "filterby[]",
    });
  }),
);

export function listBreakdownValuesRequestToJSON(
  listBreakdownValuesRequest: ListBreakdownValuesRequest,
): string {
  return JSON.stringify(
    ListBreakdownValuesRequest$outboundSchema.parse(listBreakdownValuesRequest),
  );
}

/** @internal */
export const ListBreakdownValuesResponseBody$inboundSchema: z.ZodMiniType<
  ListBreakdownValuesResponseBody,
  unknown
> = z.object({
  success: types.optional(types.boolean()),
  metadata: types.optional(models.MetricsmetadataDetails$inboundSchema),
  data: types.optional(z.array(models.MetricsBreakdownDetails$inboundSchema)),
  pagination: types.optional(models.DataPagination$inboundSchema),
  timespan: types.optional(z.array(types.number())),
});

export function listBreakdownValuesResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<ListBreakdownValuesResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListBreakdownValuesResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListBreakdownValuesResponseBody' from JSON`,
  );
}

/** @internal */
export const ListBreakdownValuesResponse$inboundSchema: z.ZodMiniType<
  ListBreakdownValuesResponse,
  unknown
> = smartUnion([
  z.lazy(() => ListBreakdownValuesResponseBody$inboundSchema),
  models.DefaultError$inboundSchema,
]);

export function listBreakdownValuesResponseFromJSON(
  jsonString: string,
): SafeParseResult<ListBreakdownValuesResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListBreakdownValuesResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListBreakdownValuesResponse' from JSON`,
  );
}
