/*
* This file is auto-generated.
 * Do not edit this file manually.
 * Your changes will be overwritten during the next generation.
 */

import * as z from "zod/v4-mini";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smartUnion.js";
import {
  AiResponseRecord,
  AiResponseRecord$inboundSchema,
} from "./airesponserecord.js";
import {
  AiSummaryRecord,
  AiSummaryRecord$inboundSchema,
} from "./aisummaryrecord.js";
import { AudioTrack, AudioTrack$inboundSchema } from "./audiotrack.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import { PlaybackId, PlaybackId$inboundSchema } from "./playbackid.js";
import { SubtitleTrack, SubtitleTrack$inboundSchema } from "./subtitletrack.js";
import {
  TracksSubtitles,
  TracksSubtitles$inboundSchema,
} from "./trackssubtitles.js";
import { VideoTrack, VideoTrack$inboundSchema } from "./videotrack.js";

/**
 * The quality tier applied to the media.
 */
export const MediaMediaQuality = {
  Standard: "standard",
  Pro: "pro",
  Premium: "premium",
} as const;
/**
 * The quality tier applied to the media.
 */
export type MediaMediaQuality = OpenEnum<typeof MediaMediaQuality>;

/**
 * The maximum resolution specified by the user for the media.
 */
export const MediaMaxResolution = {
  TwoThousandOneHundredAndSixtyp: "2160p",
  OneThousandFourHundredAndFortyp: "1440p",
  OneThousandAndEightyp: "1080p",
  SevenHundredAndTwentyp: "720p",
  FourHundredAndEightyp: "480p",
} as const;
/**
 * The maximum resolution specified by the user for the media.
 */
export type MediaMaxResolution = OpenEnum<typeof MediaMaxResolution>;

/**
 * The actual resolution of the uploaded media. This represents the native quality of the source media.
 */
export const MediaSourceResolution = {
  TwoThousandOneHundredAndSixtyp: "2160p",
  OneThousandFourHundredAndFortyp: "1440p",
  OneThousandAndEightyp: "1080p",
  SevenHundredAndTwentyp: "720p",
  FourHundredAndEightyp: "480p",
} as const;
/**
 * The actual resolution of the uploaded media. This represents the native quality of the source media.
 */
export type MediaSourceResolution = OpenEnum<typeof MediaSourceResolution>;

/**
 * Determines the media’s status, which can be one of the possible values.
 */
export const MediaStatus = {
  Created: "Created",
  Downloading: "Downloading",
  Downloaded: "Downloaded",
  Validating: "Validating",
  InQueue: "In Queue",
  Processing: "Processing",
  Ready: "Ready",
  Failed: "Failed",
} as const;
/**
 * Determines the media’s status, which can be one of the possible values.
 */
export type MediaStatus = OpenEnum<typeof MediaStatus>;

/**
 * Determines the type of MP4 support for the media.
 *
 * @remarks
 * - **none**: Disables MP4 support.
 * - **capped_4k**: Enables MP4 downloads with resolutions up to 4K.
 * - **audioOnly**: Provides an MP4 stream containing only the audio.
 * - **audioOnly,capped_4k**: Enables both MP4 video downloads (up to 4K) and an audio-only stream.
 */
export const MediaMp4Support = {
  None: "none",
  Capped4k: "capped_4k",
  AudioOnly: "audioOnly",
  AudioOnlyCapped4k: "audioOnly,capped_4k",
} as const;
/**
 * Determines the type of MP4 support for the media.
 *
 * @remarks
 * - **none**: Disables MP4 support.
 * - **capped_4k**: Enables MP4 downloads with resolutions up to 4K.
 * - **audioOnly**: Provides an MP4 stream containing only the audio.
 * - **audioOnly,capped_4k**: Enables both MP4 video downloads (up to 4K) and an audio-only stream.
 */
export type MediaMp4Support = OpenEnum<typeof MediaMp4Support>;

export type MediaTrack = VideoTrack | AudioTrack | SubtitleTrack;

export type Media = {
  /**
   * A video thumbnail is a still image that acts as the preview image for your video.
   */
  thumbnail?: string | null | undefined;
  /**
   * The unique identifier assigned to the media when created. The value must be a valid UUID.
   */
  id?: string | undefined;
  /**
   * A unique identifier is generated by FastPix for the workspace.
   */
  workspaceId?: string | undefined;
  /**
   * You can search for videos with specific key value pairs using metadata, when you tag a video in "key" : "value" pairs. Dynamic metadata allows you to define a key that allows any value pair. You can have maximum of 255 characters and upto 10 entries are allowed.
   *
   * @remarks
   */
  metadata?: { [k: string]: string } | null | undefined;
  /**
   * The quality tier applied to the media.
   */
  mediaQuality?: MediaMediaQuality | undefined;
  /**
   * The unique identifier of the user who created this media.
   */
  creatorId?: string | null | undefined;
  /**
   * Title of the media file.
   */
  title?: string | null | undefined;
  /**
   * The maximum resolution specified by the user for the media.
   */
  maxResolution?: MediaMaxResolution | undefined;
  /**
   * The actual resolution of the uploaded media. This represents the native quality of the source media.
   */
  sourceResolution?: MediaSourceResolution | undefined;
  /**
   * Determines the media’s status, which can be one of the possible values.
   */
  status?: MediaStatus | undefined;
  /**
   * Determines the type of MP4 support for the media.
   *
   * @remarks
   * - **none**: Disables MP4 support.
   * - **capped_4k**: Enables MP4 downloads with resolutions up to 4K.
   * - **audioOnly**: Provides an MP4 stream containing only the audio.
   * - **audioOnly,capped_4k**: Enables both MP4 video downloads (up to 4K) and an audio-only stream.
   */
  mp4Support?: MediaMp4Support | null | undefined;
  /**
   * The sourceAccess parameter determines whether the original media file is accessible. Set to true to enable access or false to restrict it.
   */
  sourceAccess?: boolean | null | undefined;
  /**
   * A collection of Playback ID objects utilized for crafting HLS playback URLs.
   */
  playbackIds?: Array<PlaybackId> | undefined;
  /**
   * A media consists of different media tracks, like video, audio, and subtitle, all combined.
   */
  tracks?: Array<VideoTrack | AudioTrack | SubtitleTrack> | undefined;
  /**
   * List of generated subtitle tracks associated with the media.
   */
  generatedSubtitles?: Array<TracksSubtitles> | null | undefined;
  /**
   * Represents an AI response record containing status and data for AI-generated features like summary, chapters, named entities, or moderation.
   */
  summary?: AiSummaryRecord | undefined;
  /**
   * Represents an AI response record containing status and data for AI-generated features like summary, chapters, named entities, or moderation.
   */
  chapters?: AiResponseRecord | undefined;
  /**
   * Represents an AI response record containing status and data for AI-generated features like summary, chapters, named entities, or moderation.
   */
  namedEntities?: AiResponseRecord | undefined;
  /**
   * Represents an AI response record containing status and data for AI-generated features like summary, chapters, named entities, or moderation.
   */
  moderation?: AiResponseRecord | undefined;
  /**
   * Indicates whether the media contains only audio (no video track).
   */
  isAudioOnly?: boolean | null | undefined;
  /**
   * Indicates whether subtitles are available for the media.
   */
  subtitleAvailable?: boolean | null | undefined;
  /**
   * The length of the media in seconds, with a maximum allowed duration of 12 hours per individual media.
   */
  duration?: string | undefined;
  /**
   * The aspect ratio of a video is a value that describes the relative shape of a video based on its width and height.
   */
  aspectRatio?: string | null | undefined;
  /**
   * Time the media was created, defined as a localDateTime (UTC Time).
   */
  createdAt?: Date | undefined;
  /**
   * Time the media was updated, defined as a localDateTime (UTC Time).
   */
  updatedAt?: Date | undefined;
};

/** @internal */
export const MediaMediaQuality$inboundSchema: z.ZodMiniType<
  MediaMediaQuality,
  unknown
> = openEnums.inboundSchema(MediaMediaQuality);

/** @internal */
export const MediaMaxResolution$inboundSchema: z.ZodMiniType<
  MediaMaxResolution,
  unknown
> = openEnums.inboundSchema(MediaMaxResolution);

/** @internal */
export const MediaSourceResolution$inboundSchema: z.ZodMiniType<
  MediaSourceResolution,
  unknown
> = openEnums.inboundSchema(MediaSourceResolution);

/** @internal */
export const MediaStatus$inboundSchema: z.ZodMiniType<MediaStatus, unknown> =
  openEnums.inboundSchema(MediaStatus);

/** @internal */
export const MediaMp4Support$inboundSchema: z.ZodMiniType<
  MediaMp4Support,
  unknown
> = openEnums.inboundSchema(MediaMp4Support);

/** @internal */
export const MediaTrack$inboundSchema: z.ZodMiniType<MediaTrack, unknown> =
  smartUnion([
    VideoTrack$inboundSchema,
    AudioTrack$inboundSchema,
    SubtitleTrack$inboundSchema,
  ]);

export function mediaTrackFromJSON(
  jsonString: string,
): SafeParseResult<MediaTrack, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MediaTrack$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MediaTrack' from JSON`,
  );
}

/** @internal */
export const Media$inboundSchema: z.ZodMiniType<Media, unknown> = z.object({
  thumbnail: z.optional(z.nullable(types.string())),
  id: types.optional(types.string()),
  workspaceId: types.optional(types.string()),
  metadata: z.optional(z.nullable(z.record(z.string(), types.string()))),
  mediaQuality: types.optional(MediaMediaQuality$inboundSchema),
  creatorId: z.optional(z.nullable(types.string())),
  title: z.optional(z.nullable(types.string())),
  maxResolution: z._default(MediaMaxResolution$inboundSchema, "1080p"),
  sourceResolution: z._default(MediaSourceResolution$inboundSchema, "1080p"),
  status: types.optional(MediaStatus$inboundSchema),
  mp4Support: z.optional(z.nullable(MediaMp4Support$inboundSchema)),
  sourceAccess: z.optional(z.nullable(types.boolean())),
  playbackIds: types.optional(z.array(PlaybackId$inboundSchema)),
  tracks: types.optional(
    z.array(
      smartUnion([
        VideoTrack$inboundSchema,
        AudioTrack$inboundSchema,
        SubtitleTrack$inboundSchema,
      ]),
    ),
  ),
  generatedSubtitles: z.optional(
    z.nullable(z.array(TracksSubtitles$inboundSchema)),
  ),
  summary: types.optional(AiSummaryRecord$inboundSchema),
  chapters: types.optional(AiResponseRecord$inboundSchema),
  namedEntities: types.optional(AiResponseRecord$inboundSchema),
  moderation: types.optional(AiResponseRecord$inboundSchema),
  isAudioOnly: z.optional(z.nullable(types.boolean())),
  subtitleAvailable: z.optional(z.nullable(types.boolean())),
  duration: types.optional(types.string()),
  aspectRatio: z.optional(z.nullable(types.string())),
  createdAt: types.optional(types.date()),
  updatedAt: types.optional(types.date()),
});

export function mediaFromJSON(
  jsonString: string,
): SafeParseResult<Media, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Media$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Media' from JSON`,
  );
}
