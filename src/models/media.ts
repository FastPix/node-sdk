import * as z from "zod";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  PlaybackId,
  PlaybackId$inboundSchema,
  PlaybackId$Outbound,
  PlaybackId$outboundSchema,
} from "./playbackid.js";
import {
  Track,
  Track$inboundSchema,
  Track$Outbound,
  Track$outboundSchema,
} from "./track.js";

/**
 * The maximum resolution specified by the user for the media.
 */
export const MediaMaxResolution = {
  TwoThousandOneHundredAndSixtyp: "2160p",
  OneThousandFourHundredAndFortyp: "1440p",
  OneThousandAndEightyp: "1080p",
  SevenHundredAndTwentyp: "720p",
  FourHundredAndEightyp: "480p",
  ThreeHundredAndSixtyp: "360p",
} as const;
/**
 * The maximum resolution specified by the user for the media.
 */
export type MediaMaxResolution = ClosedEnum<typeof MediaMaxResolution>;

/**
 * The actual resolution of the uploaded media. This represents the native quality of the source media.
 */
export const MediaSourceResolution = {
  TwoThousandOneHundredAndSixtyp: "2160p",
  OneThousandFourHundredAndFortyp: "1440p",
  OneThousandAndEightyp: "1080p",
  SevenHundredAndTwentyp: "720p",
  FourHundredAndEightyp: "480p",
  ThreeHundredAndSixtyp: "360p",
} as const;
/**
 * The actual resolution of the uploaded media. This represents the native quality of the source media.
 */
export type MediaSourceResolution = ClosedEnum<typeof MediaSourceResolution>;

/**
 * Determines the type of MP4 support for the media.   - **none**: Disables MP4 support.   - **capped_4k**: Enables MP4 downloads with resolutions up to 4K.   - **audioOnly**: Provides an MP4 stream containing only the audio.   - **audioOnly,capped_4k**: Enables both MP4 video downloads (up to 4K) and an audio-only stream.
 */
export const MediaMp4Support = {
  None: "none",
  Capped4k: "capped_4k",
  AudioOnly: "audioOnly",
  AudioOnlyCapped4k: "audioOnly,capped_4k",
} as const;
/**
 * Determines the type of MP4 support for the media.   - **none**: Disables MP4 support.   - **capped_4k**: Enables MP4 downloads with resolutions up to 4K.   - **audioOnly**: Provides an MP4 stream containing only the audio.   - **audioOnly,capped_4k**: Enables both MP4 video downloads (up to 4K) and an audio-only stream.
 */
export type MediaMp4Support = ClosedEnum<typeof MediaMp4Support>;

export type Media = {
  /**
   * A video thumbnail is a still image that acts as the preview image for your video.
   */
  thumbnail?: string | undefined;
  /**
   * When creating the media, FastPix assigns a universally unique identifier with a maximum length of 255 characters.
   */
  id?: string | undefined;
  /**
   * A unique identifier is generated by FastPix for the workspace.
   */
  workspaceId?: string | undefined;
  /**
   * You can search for videos with specific key value pairs using metadata, when you tag a video in "key" : "value" pairs. Dynamic Metadata allows you to define a key that allows any value pair. You can have maximum of 255 characters and upto 10 entries are allowed.
   */
  metadata?: { [k: string]: string } | undefined;
  /**
   * The maximum resolution specified by the user for the media.
   */
  maxResolution?: MediaMaxResolution | undefined;
  /**
   * The actual resolution of the uploaded media. This represents the native quality of the source media.
   */
  sourceResolution?: MediaSourceResolution | undefined;
  /**
   * Determines the media's status, which can be one of the possible values.
   */
  status?: string | undefined;
  /**
   * Determines the type of MP4 support for the media.   - **none**: Disables MP4 support.   - **capped_4k**: Enables MP4 downloads with resolutions up to 4K.   - **audioOnly**: Provides an MP4 stream containing only the audio.   - **audioOnly,capped_4k**: Enables both MP4 video downloads (up to 4K) and an audio-only stream.
   */
  mp4Support?: MediaMp4Support | undefined;
  /**
   * The sourceAccess parameter determines whether the original media file is accessible. Set to true to enable access or false to restrict it
   */
  sourceAccess?: boolean | undefined;
  /**
   * A collection of Playback ID objects utilized for crafting HLS playback URLs.
   */
  playbackIds?: Array<PlaybackId> | undefined;
  /**
   * A media consists of different media tracks, like video, audio, and subtitle, all combined.
   */
  tracks?: Array<Track> | undefined;
  /**
   * The time span of the media, measured in seconds with a maximum allowable duration of 12 hours per individual media.
   */
  duration?: string | undefined;
  /**
   * Frame rate quantifies the speed at which frames are displayed per second. It represents the range of frames available for a specific track. If the frame rate of the input file is indeterminable, it will be indicated by a value of -1.
   */
  frameRate?: string | undefined;
  /**
   * The aspect ratio of a video is a value that describes the relative shape of a video based on its width and height.
   */
  aspectRatio?: string | undefined;
  /**
   * Time the media was created, defined as a localDateTime (UTC Time).
   */
  createdAt?: Date | undefined;
  /**
   * Time the media was updated, defined as a localDateTime (UTC Time).
   */
  updatedAt?: Date | undefined;
};

/** @internal */
export const MediaMaxResolution$inboundSchema: z.ZodNativeEnum<
  typeof MediaMaxResolution
> = z.nativeEnum(MediaMaxResolution);

/** @internal */
export const MediaMaxResolution$outboundSchema: z.ZodNativeEnum<
  typeof MediaMaxResolution
> = MediaMaxResolution$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MediaMaxResolution$ {
  /** @deprecated use `MediaMaxResolution$inboundSchema` instead. */
  export const inboundSchema = MediaMaxResolution$inboundSchema;
  /** @deprecated use `MediaMaxResolution$outboundSchema` instead. */
  export const outboundSchema = MediaMaxResolution$outboundSchema;
}

/** @internal */
export const MediaSourceResolution$inboundSchema: z.ZodNativeEnum<
  typeof MediaSourceResolution
> = z.nativeEnum(MediaSourceResolution);

/** @internal */
export const MediaSourceResolution$outboundSchema: z.ZodNativeEnum<
  typeof MediaSourceResolution
> = MediaSourceResolution$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MediaSourceResolution$ {
  /** @deprecated use `MediaSourceResolution$inboundSchema` instead. */
  export const inboundSchema = MediaSourceResolution$inboundSchema;
  /** @deprecated use `MediaSourceResolution$outboundSchema` instead. */
  export const outboundSchema = MediaSourceResolution$outboundSchema;
}

/** @internal */
export const MediaMp4Support$inboundSchema: z.ZodNativeEnum<
  typeof MediaMp4Support
> = z.nativeEnum(MediaMp4Support);

/** @internal */
export const MediaMp4Support$outboundSchema: z.ZodNativeEnum<
  typeof MediaMp4Support
> = MediaMp4Support$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MediaMp4Support$ {
  /** @deprecated use `MediaMp4Support$inboundSchema` instead. */
  export const inboundSchema = MediaMp4Support$inboundSchema;
  /** @deprecated use `MediaMp4Support$outboundSchema` instead. */
  export const outboundSchema = MediaMp4Support$outboundSchema;
}

/** @internal */
export const Media$inboundSchema: z.ZodType<Media, z.ZodTypeDef, unknown> = z
  .object({
    thumbnail: z.string().optional(),
    id: z.string().optional(),
    workspaceId: z.string().optional(),
    metadata: z.record(z.string()).optional(),
    maxResolution: MediaMaxResolution$inboundSchema.default("1080p"),
    sourceResolution: MediaSourceResolution$inboundSchema.default("1080p"),
    status: z.string().optional(),
    mp4Support: MediaMp4Support$inboundSchema.optional(),
    sourceAccess: z.boolean().optional(),
    playbackIds: z.array(PlaybackId$inboundSchema).optional(),
    tracks: z.array(Track$inboundSchema).optional(),
    duration: z.string().optional(),
    frameRate: z.string().optional(),
    aspectRatio: z.string().optional(),
    createdAt: z.string().datetime({ offset: true }).transform(v => new Date(v))
      .optional(),
    updatedAt: z.string().datetime({ offset: true }).transform(v => new Date(v))
      .optional(),
  });

/** @internal */
export type Media$Outbound = {
  thumbnail?: string | undefined;
  id?: string | undefined;
  workspaceId?: string | undefined;
  metadata?: { [k: string]: string } | undefined;
  maxResolution: string;
  sourceResolution: string;
  status?: string | undefined;
  mp4Support?: string | undefined;
  sourceAccess?: boolean | undefined;
  playbackIds?: Array<PlaybackId$Outbound> | undefined;
  tracks?: Array<Track$Outbound> | undefined;
  duration?: string | undefined;
  frameRate?: string | undefined;
  aspectRatio?: string | undefined;
  createdAt?: string | undefined;
  updatedAt?: string | undefined;
};

/** @internal */
export const Media$outboundSchema: z.ZodType<
  Media$Outbound,
  z.ZodTypeDef,
  Media
> = z.object({
  thumbnail: z.string().optional(),
  id: z.string().optional(),
  workspaceId: z.string().optional(),
  metadata: z.record(z.string()).optional(),
  maxResolution: MediaMaxResolution$outboundSchema.default("1080p"),
  sourceResolution: MediaSourceResolution$outboundSchema.default("1080p"),
  status: z.string().optional(),
  mp4Support: MediaMp4Support$outboundSchema.optional(),
  sourceAccess: z.boolean().optional(),
  playbackIds: z.array(PlaybackId$outboundSchema).optional(),
  tracks: z.array(Track$outboundSchema).optional(),
  duration: z.string().optional(),
  frameRate: z.string().optional(),
  aspectRatio: z.string().optional(),
  createdAt: z.date().transform(v => v.toISOString()).optional(),
  updatedAt: z.date().transform(v => v.toISOString()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Media$ {
  /** @deprecated use `Media$inboundSchema` instead. */
  export const inboundSchema = Media$inboundSchema;
  /** @deprecated use `Media$outboundSchema` instead. */
  export const outboundSchema = Media$outboundSchema;
  /** @deprecated use `Media$Outbound` instead. */
  export type Outbound = Media$Outbound;
}

export function mediaToJSON(media: Media): string {
  return JSON.stringify(Media$outboundSchema.parse(media));
}

export function mediaFromJSON(
  jsonString: string,
): SafeParseResult<Media, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Media$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Media' from JSON`,
  );
}
